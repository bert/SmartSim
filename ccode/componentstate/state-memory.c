/* state-memory.c generated by valac 0.16.0, the Vala compiler
 * generated from state-memory.vala, do not modify */

/* 
 * SmartSim - Digital Logic Circuit Designer and Simulator
 *   
 *   Expansion Version
 *   
 *   Filename: componentstate/memory.vala
 *   
 *   Copyright Ashley Newson 2012
 */

#include <glib.h>
#include <glib-object.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <stdio.h>


#define TYPE_COMPONENT_STATE (component_state_get_type ())
#define COMPONENT_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_STATE, ComponentState))
#define COMPONENT_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_STATE, ComponentStateClass))
#define IS_COMPONENT_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_STATE))
#define IS_COMPONENT_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_STATE))
#define COMPONENT_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_STATE, ComponentStateClass))

typedef struct _ComponentState ComponentState;
typedef struct _ComponentStateClass ComponentStateClass;
typedef struct _ComponentStatePrivate ComponentStatePrivate;

#define TYPE_COMPILED_CIRCUIT (compiled_circuit_get_type ())
#define COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuit))
#define COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))
#define IS_COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPILED_CIRCUIT))
#define IS_COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPILED_CIRCUIT))
#define COMPILED_CIRCUIT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))

typedef struct _CompiledCircuit CompiledCircuit;
typedef struct _CompiledCircuitClass CompiledCircuitClass;

#define TYPE_COMPONENT_INST (component_inst_get_type ())
#define COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_INST, ComponentInst))
#define COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_INST, ComponentInstClass))
#define IS_COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_INST))
#define IS_COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_INST))
#define COMPONENT_INST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_INST, ComponentInstClass))

typedef struct _ComponentInst ComponentInst;
typedef struct _ComponentInstClass ComponentInstClass;

#define TYPE_MEMORY_COMPONENT_STATE (memory_component_state_get_type ())
#define MEMORY_COMPONENT_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MEMORY_COMPONENT_STATE, MemoryComponentState))
#define MEMORY_COMPONENT_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MEMORY_COMPONENT_STATE, MemoryComponentStateClass))
#define IS_MEMORY_COMPONENT_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MEMORY_COMPONENT_STATE))
#define IS_MEMORY_COMPONENT_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MEMORY_COMPONENT_STATE))
#define MEMORY_COMPONENT_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MEMORY_COMPONENT_STATE, MemoryComponentStateClass))

typedef struct _MemoryComponentState MemoryComponentState;
typedef struct _MemoryComponentStateClass MemoryComponentStateClass;
typedef struct _MemoryComponentStatePrivate MemoryComponentStatePrivate;

#define TYPE_CONNECTION (connection_get_type ())
#define CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONNECTION, Connection))
#define CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONNECTION, ConnectionClass))
#define IS_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONNECTION))
#define IS_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONNECTION))
#define CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONNECTION, ConnectionClass))

typedef struct _Connection Connection;
typedef struct _ConnectionClass ConnectionClass;

#define MEMORY_COMPONENT_STATE_TYPE_MEMORY_TYPE (memory_component_state_memory_type_get_type ())
#define _connection_unref0(var) ((var == NULL) ? NULL : (var = (connection_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _component_state_unref0(var) ((var == NULL) ? NULL : (var = (component_state_unref (var), NULL)))
#define _component_inst_unref0(var) ((var == NULL) ? NULL : (var = (component_inst_unref (var), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))

struct _ComponentState {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ComponentStatePrivate * priv;
	CompiledCircuit* compiledCircuit;
	ComponentInst** ancestry;
	gint ancestry_length1;
	ComponentInst* componentInst;
	gint renderQueueID;
	gint processQueueID;
	gboolean display;
};

struct _ComponentStateClass {
	GTypeClass parent_class;
	void (*finalize) (ComponentState *self);
	void (*update) (ComponentState* self);
	void (*click) (ComponentState* self);
	void (*render) (ComponentState* self, cairo_t* context);
	gboolean (*get_alwaysUpdate) (ComponentState* self);
};

struct _MemoryComponentState {
	ComponentState parent_instance;
	MemoryComponentStatePrivate * priv;
};

struct _MemoryComponentStateClass {
	ComponentStateClass parent_class;
};

typedef enum  {
	MEMORY_COMPONENT_STATE_MEMORY_TYPE_RAM_CS_RE_WE,
	MEMORY_COMPONENT_STATE_MEMORY_TYPE_ROM_CS
} MemoryComponentStateMemoryType;

struct _MemoryComponentStatePrivate {
	Connection** addressWires;
	gint addressWires_length1;
	gint _addressWires_size_;
	Connection** dataWires;
	gint dataWires_length1;
	gint _dataWires_size_;
	Connection* selectWire;
	Connection* readEnableWire;
	Connection* writeEnableWire;
	Connection* clockWire;
	MemoryComponentStateMemoryType memoryType;
	guint width;
	guint64 memorySize;
	guint64 memorySizeBytes;
	guint64 addresses;
	gchar* memory;
	gboolean previousClockSignal;
	gchar* readFilename;
	gchar* writeFilename;
};

typedef enum  {
	COMPONENT_STATE_ERROR_COMPILE
} ComponentStateError;
#define COMPONENT_STATE_ERROR component_state_error_quark ()

static gpointer memory_component_state_parent_class = NULL;

gpointer component_state_ref (gpointer instance);
void component_state_unref (gpointer instance);
GParamSpec* param_spec_component_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_state (GValue* value, gpointer v_object);
void value_take_component_state (GValue* value, gpointer v_object);
gpointer value_get_component_state (const GValue* value);
GType component_state_get_type (void) G_GNUC_CONST;
gpointer compiled_circuit_ref (gpointer instance);
void compiled_circuit_unref (gpointer instance);
GParamSpec* param_spec_compiled_circuit (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_compiled_circuit (GValue* value, gpointer v_object);
void value_take_compiled_circuit (GValue* value, gpointer v_object);
gpointer value_get_compiled_circuit (const GValue* value);
GType compiled_circuit_get_type (void) G_GNUC_CONST;
gpointer component_inst_ref (gpointer instance);
void component_inst_unref (gpointer instance);
GParamSpec* param_spec_component_inst (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_inst (GValue* value, gpointer v_object);
void value_take_component_inst (GValue* value, gpointer v_object);
gpointer value_get_component_inst (const GValue* value);
GType component_inst_get_type (void) G_GNUC_CONST;
GType memory_component_state_get_type (void) G_GNUC_CONST;
gpointer connection_ref (gpointer instance);
void connection_unref (gpointer instance);
GParamSpec* param_spec_connection (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_connection (GValue* value, gpointer v_object);
void value_take_connection (GValue* value, gpointer v_object);
gpointer value_get_connection (const GValue* value);
GType connection_get_type (void) G_GNUC_CONST;
static GType memory_component_state_memory_type_get_type (void) G_GNUC_UNUSED;
#define MEMORY_COMPONENT_STATE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MEMORY_COMPONENT_STATE, MemoryComponentStatePrivate))
enum  {
	MEMORY_COMPONENT_STATE_DUMMY_PROPERTY
};
static void memory_component_state_write_file (MemoryComponentState* self);
GQuark component_state_error_quark (void);
MemoryComponentState* memory_component_state_new (Connection** addressWires, int addressWires_length1, Connection** dataWires, int dataWires_length1, Connection* selectWire, Connection* readEnableWire, Connection* writeEnableWire, Connection* clockWire, gboolean readWrite, const gchar* readFilename, const gchar* writeFilename, ComponentInst** ancestry, int ancestry_length1, ComponentInst* componentInst, GError** error);
MemoryComponentState* memory_component_state_construct (GType object_type, Connection** addressWires, int addressWires_length1, Connection** dataWires, int dataWires_length1, Connection* selectWire, Connection* readEnableWire, Connection* writeEnableWire, Connection* clockWire, gboolean readWrite, const gchar* readFilename, const gchar* writeFilename, ComponentInst** ancestry, int ancestry_length1, ComponentInst* componentInst, GError** error);
ComponentState* component_state_construct (GType object_type);
static Connection** _vala_array_dup76 (Connection** self, int length);
void connection_set_affects (Connection* self, ComponentState* componentState);
static Connection** _vala_array_dup77 (Connection** self, int length);
static gint memory_component_state_allocate_memory (MemoryComponentState* self);
static void memory_component_state_read_file (MemoryComponentState* self);
static ComponentInst** _vala_array_dup78 (ComponentInst** self, int length);
static gboolean memory_component_state_get_memory (MemoryComponentState* self, guint address, guint bit);
static void memory_component_state_set_memory (MemoryComponentState* self, guint address, guint bit, gboolean bitValue);
static void memory_component_state_real_update (ComponentState* base);
gboolean connection_get_signalState (Connection* self);
void connection_set_signalState (Connection* self, gboolean value);
void connection_disable_signal (Connection* self);
static void memory_component_state_finalize (ComponentState* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static GType memory_component_state_memory_type_get_type (void) {
	static volatile gsize memory_component_state_memory_type_type_id__volatile = 0;
	if (g_once_init_enter (&memory_component_state_memory_type_type_id__volatile)) {
		static const GEnumValue values[] = {{MEMORY_COMPONENT_STATE_MEMORY_TYPE_RAM_CS_RE_WE, "MEMORY_COMPONENT_STATE_MEMORY_TYPE_RAM_CS_RE_WE", "ram-cs-re-we"}, {MEMORY_COMPONENT_STATE_MEMORY_TYPE_ROM_CS, "MEMORY_COMPONENT_STATE_MEMORY_TYPE_ROM_CS", "rom-cs"}, {0, NULL, NULL}};
		GType memory_component_state_memory_type_type_id;
		memory_component_state_memory_type_type_id = g_enum_register_static ("MemoryComponentStateMemoryType", values);
		g_once_init_leave (&memory_component_state_memory_type_type_id__volatile, memory_component_state_memory_type_type_id);
	}
	return memory_component_state_memory_type_type_id__volatile;
}


static gpointer _connection_ref0 (gpointer self) {
	return self ? connection_ref (self) : NULL;
}


static Connection** _vala_array_dup76 (Connection** self, int length) {
	Connection** result;
	int i;
	result = g_new0 (Connection*, length + 1);
	for (i = 0; i < length; i++) {
		Connection* _tmp0_;
		_tmp0_ = _connection_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static Connection** _vala_array_dup77 (Connection** self, int length) {
	Connection** result;
	int i;
	result = g_new0 (Connection*, length + 1);
	for (i = 0; i < length; i++) {
		Connection* _tmp0_;
		_tmp0_ = _connection_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static gpointer _component_inst_ref0 (gpointer self) {
	return self ? component_inst_ref (self) : NULL;
}


static ComponentInst** _vala_array_dup78 (ComponentInst** self, int length) {
	ComponentInst** result;
	int i;
	result = g_new0 (ComponentInst*, length + 1);
	for (i = 0; i < length; i++) {
		ComponentInst* _tmp0_;
		_tmp0_ = _component_inst_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


MemoryComponentState* memory_component_state_construct (GType object_type, Connection** addressWires, int addressWires_length1, Connection** dataWires, int dataWires_length1, Connection* selectWire, Connection* readEnableWire, Connection* writeEnableWire, Connection* clockWire, gboolean readWrite, const gchar* readFilename, const gchar* writeFilename, ComponentInst** ancestry, int ancestry_length1, ComponentInst* componentInst, GError** error) {
	MemoryComponentState* self = NULL;
	Connection** _tmp0_;
	gint _tmp0__length1;
	Connection** _tmp1_;
	gint _tmp1__length1;
	Connection** _tmp2_;
	gint _tmp2__length1;
	Connection** _tmp5_;
	gint _tmp5__length1;
	Connection** _tmp6_;
	gint _tmp6__length1;
	Connection** _tmp7_;
	gint _tmp7__length1;
	Connection* _tmp10_;
	Connection* _tmp11_;
	Connection* _tmp12_;
	Connection* _tmp13_;
	Connection* _tmp14_;
	Connection* _tmp15_;
	Connection* _tmp16_;
	Connection* _tmp17_;
	Connection* _tmp18_;
	Connection* _tmp19_;
	Connection* _tmp20_;
	Connection* _tmp21_;
	const gchar* _tmp22_;
	gchar* _tmp23_;
	const gchar* _tmp24_;
	gchar* _tmp25_;
	gboolean _tmp26_;
	Connection** _tmp27_;
	gint _tmp27__length1;
	Connection** _tmp29_;
	gint _tmp29__length1;
	Connection** _tmp38_;
	gint _tmp38__length1;
	Connection** _tmp39_;
	gint _tmp39__length1;
	gfloat _tmp40_ = 0.0F;
	gfloat _tmp41_ = 0.0F;
	Connection** _tmp43_;
	gint _tmp43__length1;
	Connection** _tmp44_;
	gint _tmp44__length1;
	guint64 _tmp45_;
	guint _tmp46_;
	guint64 _tmp47_;
	gint _tmp48_ = 0;
	gint allocationResult;
	gint _tmp49_;
	ComponentInst** _tmp75_;
	gint _tmp75__length1;
	ComponentInst** _tmp76_;
	gint _tmp76__length1;
	ComponentInst* _tmp77_;
	ComponentInst* _tmp78_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (selectWire != NULL, NULL);
	g_return_val_if_fail (readEnableWire != NULL, NULL);
	g_return_val_if_fail (writeEnableWire != NULL, NULL);
	g_return_val_if_fail (clockWire != NULL, NULL);
	g_return_val_if_fail (readFilename != NULL, NULL);
	g_return_val_if_fail (writeFilename != NULL, NULL);
	g_return_val_if_fail (componentInst != NULL, NULL);
	self = (MemoryComponentState*) component_state_construct (object_type);
	_tmp0_ = addressWires;
	_tmp0__length1 = addressWires_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup76 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	self->priv->addressWires = (_vala_array_free (self->priv->addressWires, self->priv->addressWires_length1, (GDestroyNotify) connection_unref), NULL);
	self->priv->addressWires = _tmp1_;
	self->priv->addressWires_length1 = _tmp1__length1;
	self->priv->_addressWires_size_ = self->priv->addressWires_length1;
	_tmp2_ = addressWires;
	_tmp2__length1 = addressWires_length1;
	{
		Connection** addressWire_collection = NULL;
		gint addressWire_collection_length1 = 0;
		gint _addressWire_collection_size_ = 0;
		gint addressWire_it = 0;
		addressWire_collection = _tmp2_;
		addressWire_collection_length1 = _tmp2__length1;
		for (addressWire_it = 0; addressWire_it < _tmp2__length1; addressWire_it = addressWire_it + 1) {
			Connection* _tmp3_;
			Connection* addressWire = NULL;
			_tmp3_ = _connection_ref0 (addressWire_collection[addressWire_it]);
			addressWire = _tmp3_;
			{
				Connection* _tmp4_;
				_tmp4_ = addressWire;
				connection_set_affects (_tmp4_, (ComponentState*) self);
				_connection_unref0 (addressWire);
			}
		}
	}
	_tmp5_ = dataWires;
	_tmp5__length1 = dataWires_length1;
	_tmp6_ = (_tmp5_ != NULL) ? _vala_array_dup77 (_tmp5_, _tmp5__length1) : ((gpointer) _tmp5_);
	_tmp6__length1 = _tmp5__length1;
	self->priv->dataWires = (_vala_array_free (self->priv->dataWires, self->priv->dataWires_length1, (GDestroyNotify) connection_unref), NULL);
	self->priv->dataWires = _tmp6_;
	self->priv->dataWires_length1 = _tmp6__length1;
	self->priv->_dataWires_size_ = self->priv->dataWires_length1;
	_tmp7_ = dataWires;
	_tmp7__length1 = dataWires_length1;
	{
		Connection** dataWire_collection = NULL;
		gint dataWire_collection_length1 = 0;
		gint _dataWire_collection_size_ = 0;
		gint dataWire_it = 0;
		dataWire_collection = _tmp7_;
		dataWire_collection_length1 = _tmp7__length1;
		for (dataWire_it = 0; dataWire_it < _tmp7__length1; dataWire_it = dataWire_it + 1) {
			Connection* _tmp8_;
			Connection* dataWire = NULL;
			_tmp8_ = _connection_ref0 (dataWire_collection[dataWire_it]);
			dataWire = _tmp8_;
			{
				Connection* _tmp9_;
				_tmp9_ = dataWire;
				connection_set_affects (_tmp9_, (ComponentState*) self);
				_connection_unref0 (dataWire);
			}
		}
	}
	_tmp10_ = selectWire;
	_tmp11_ = _connection_ref0 (_tmp10_);
	_connection_unref0 (self->priv->selectWire);
	self->priv->selectWire = _tmp11_;
	_tmp12_ = selectWire;
	connection_set_affects (_tmp12_, (ComponentState*) self);
	_tmp13_ = readEnableWire;
	_tmp14_ = _connection_ref0 (_tmp13_);
	_connection_unref0 (self->priv->readEnableWire);
	self->priv->readEnableWire = _tmp14_;
	_tmp15_ = readEnableWire;
	connection_set_affects (_tmp15_, (ComponentState*) self);
	_tmp16_ = writeEnableWire;
	_tmp17_ = _connection_ref0 (_tmp16_);
	_connection_unref0 (self->priv->writeEnableWire);
	self->priv->writeEnableWire = _tmp17_;
	_tmp18_ = writeEnableWire;
	connection_set_affects (_tmp18_, (ComponentState*) self);
	_tmp19_ = clockWire;
	_tmp20_ = _connection_ref0 (_tmp19_);
	_connection_unref0 (self->priv->clockWire);
	self->priv->clockWire = _tmp20_;
	_tmp21_ = clockWire;
	connection_set_affects (_tmp21_, (ComponentState*) self);
	_tmp22_ = readFilename;
	_tmp23_ = g_strdup (_tmp22_);
	_g_free0 (self->priv->readFilename);
	self->priv->readFilename = _tmp23_;
	_tmp24_ = writeFilename;
	_tmp25_ = g_strdup (_tmp24_);
	_g_free0 (self->priv->writeFilename);
	self->priv->writeFilename = _tmp25_;
	_tmp26_ = readWrite;
	if (_tmp26_) {
		self->priv->memoryType = MEMORY_COMPONENT_STATE_MEMORY_TYPE_RAM_CS_RE_WE;
	} else {
		self->priv->memoryType = MEMORY_COMPONENT_STATE_MEMORY_TYPE_ROM_CS;
	}
	_tmp27_ = addressWires;
	_tmp27__length1 = addressWires_length1;
	if (_tmp27__length1 >= 64) {
		GError* _tmp28_;
		_tmp28_ = g_error_new_literal (COMPONENT_STATE_ERROR, COMPONENT_STATE_ERROR_COMPILE, "Memory chips with 64 or more address wires are not supported.");
		_inner_error_ = _tmp28_;
		if (_inner_error_->domain == COMPONENT_STATE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_component_state_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp29_ = addressWires;
	_tmp29__length1 = addressWires_length1;
	if (((gulong) _tmp29__length1) >= (sizeof (guint) * 8)) {
		gchar* _tmp30_ = NULL;
		gchar* _tmp31_;
		gchar* _tmp32_;
		gchar* _tmp33_;
		gchar* _tmp34_;
		gchar* _tmp35_;
		GError* _tmp36_;
		GError* _tmp37_;
		_tmp30_ = g_strdup_printf ("%lu", ((gulong) sizeof (guint)) * 8);
		_tmp31_ = _tmp30_;
		_tmp32_ = g_strconcat ("Memory chips with ", _tmp31_, NULL);
		_tmp33_ = _tmp32_;
		_tmp34_ = g_strconcat (_tmp33_, " or more address wires are not supported on this host system.", NULL);
		_tmp35_ = _tmp34_;
		_tmp36_ = g_error_new_literal (COMPONENT_STATE_ERROR, COMPONENT_STATE_ERROR_COMPILE, _tmp35_);
		_tmp37_ = _tmp36_;
		_g_free0 (_tmp35_);
		_g_free0 (_tmp33_);
		_g_free0 (_tmp31_);
		_inner_error_ = _tmp37_;
		if (_inner_error_->domain == COMPONENT_STATE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_component_state_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp38_ = addressWires;
	_tmp38__length1 = addressWires_length1;
	_tmp39_ = dataWires;
	_tmp39__length1 = dataWires_length1;
	_tmp40_ = logf ((gfloat) _tmp39__length1);
	_tmp41_ = logf (8.0f);
	if (((gdouble) (((gfloat) _tmp38__length1) + ((gfloat) (_tmp40_ / _tmp41_)))) >= 61.0) {
		GError* _tmp42_;
		_tmp42_ = g_error_new_literal (COMPONENT_STATE_ERROR, COMPONENT_STATE_ERROR_COMPILE, "Memory chips which store 2^64 or more bits are not supported.");
		_inner_error_ = _tmp42_;
		if (_inner_error_->domain == COMPONENT_STATE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_component_state_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp43_ = addressWires;
	_tmp43__length1 = addressWires_length1;
	self->priv->addresses = ((guint64) 1) << _tmp43__length1;
	_tmp44_ = dataWires;
	_tmp44__length1 = dataWires_length1;
	self->priv->width = (guint) _tmp44__length1;
	_tmp45_ = self->priv->addresses;
	_tmp46_ = self->priv->width;
	self->priv->memorySize = _tmp45_ * ((guint64) _tmp46_);
	_tmp47_ = self->priv->memorySize;
	self->priv->memorySizeBytes = (_tmp47_ + ((guint64) 7)) / ((guint64) 8);
	_tmp48_ = memory_component_state_allocate_memory (self);
	allocationResult = _tmp48_;
	_tmp49_ = allocationResult;
	switch (_tmp49_) {
		case 1:
		{
			guint64 _tmp50_;
			gchar* _tmp51_ = NULL;
			gchar* _tmp52_;
			gchar* _tmp53_;
			gchar* _tmp54_;
			gchar* _tmp55_;
			gchar* _tmp56_;
			GError* _tmp57_;
			GError* _tmp58_;
			_tmp50_ = self->priv->memorySizeBytes;
			_tmp51_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp50_);
			_tmp52_ = _tmp51_;
			_tmp53_ = g_strconcat ("The host system does not have enough free memory to emulate this memor" \
"y chip of size ", _tmp52_, NULL);
			_tmp54_ = _tmp53_;
			_tmp55_ = g_strconcat (_tmp54_, " bytes.", NULL);
			_tmp56_ = _tmp55_;
			_tmp57_ = g_error_new_literal (COMPONENT_STATE_ERROR, COMPONENT_STATE_ERROR_COMPILE, _tmp56_);
			_tmp58_ = _tmp57_;
			_g_free0 (_tmp56_);
			_g_free0 (_tmp54_);
			_g_free0 (_tmp52_);
			_inner_error_ = _tmp58_;
			if (_inner_error_->domain == COMPONENT_STATE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_component_state_unref0 (self);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		case 2:
		{
			gulong _tmp59_;
			gchar* _tmp60_ = NULL;
			gchar* _tmp61_;
			gchar* _tmp62_;
			gchar* _tmp63_;
			gchar* _tmp64_;
			gchar* _tmp65_;
			guint64 _tmp66_;
			gchar* _tmp67_ = NULL;
			gchar* _tmp68_;
			gchar* _tmp69_;
			gchar* _tmp70_;
			gchar* _tmp71_;
			gchar* _tmp72_;
			GError* _tmp73_;
			GError* _tmp74_;
			_tmp59_ = G_MAXSIZE;
			_tmp60_ = g_strdup_printf ("%lu", _tmp59_);
			_tmp61_ = _tmp60_;
			_tmp62_ = g_strconcat ("The host system does not support memory chips of size greater than ", _tmp61_, NULL);
			_tmp63_ = _tmp62_;
			_tmp64_ = g_strconcat (_tmp63_, " bytes. Required ", NULL);
			_tmp65_ = _tmp64_;
			_tmp66_ = self->priv->memorySizeBytes;
			_tmp67_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp66_);
			_tmp68_ = _tmp67_;
			_tmp69_ = g_strconcat (_tmp65_, _tmp68_, NULL);
			_tmp70_ = _tmp69_;
			_tmp71_ = g_strconcat (_tmp70_, " bytes.", NULL);
			_tmp72_ = _tmp71_;
			_tmp73_ = g_error_new_literal (COMPONENT_STATE_ERROR, COMPONENT_STATE_ERROR_COMPILE, _tmp72_);
			_tmp74_ = _tmp73_;
			_g_free0 (_tmp72_);
			_g_free0 (_tmp70_);
			_g_free0 (_tmp68_);
			_g_free0 (_tmp65_);
			_g_free0 (_tmp63_);
			_g_free0 (_tmp61_);
			_inner_error_ = _tmp74_;
			if (_inner_error_->domain == COMPONENT_STATE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_component_state_unref0 (self);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		default:
		break;
	}
	memory_component_state_read_file (self);
	_tmp75_ = ancestry;
	_tmp75__length1 = ancestry_length1;
	_tmp76_ = (_tmp75_ != NULL) ? _vala_array_dup78 (_tmp75_, _tmp75__length1) : ((gpointer) _tmp75_);
	_tmp76__length1 = _tmp75__length1;
	((ComponentState*) self)->ancestry = (_vala_array_free (((ComponentState*) self)->ancestry, ((ComponentState*) self)->ancestry_length1, (GDestroyNotify) component_inst_unref), NULL);
	((ComponentState*) self)->ancestry = _tmp76_;
	((ComponentState*) self)->ancestry_length1 = _tmp76__length1;
	_tmp77_ = componentInst;
	_tmp78_ = _component_inst_ref0 (_tmp77_);
	_component_inst_unref0 (((ComponentState*) self)->componentInst);
	((ComponentState*) self)->componentInst = _tmp78_;
	return self;
}


MemoryComponentState* memory_component_state_new (Connection** addressWires, int addressWires_length1, Connection** dataWires, int dataWires_length1, Connection* selectWire, Connection* readEnableWire, Connection* writeEnableWire, Connection* clockWire, gboolean readWrite, const gchar* readFilename, const gchar* writeFilename, ComponentInst** ancestry, int ancestry_length1, ComponentInst* componentInst, GError** error) {
	return memory_component_state_construct (TYPE_MEMORY_COMPONENT_STATE, addressWires, addressWires_length1, dataWires, dataWires_length1, selectWire, readEnableWire, writeEnableWire, clockWire, readWrite, readFilename, writeFilename, ancestry, ancestry_length1, componentInst, error);
}


static void memory_component_state_read_file (MemoryComponentState* self) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	FILE* _tmp2_ = NULL;
	FILE* readFile;
	FILE* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->readFilename;
	if (g_strcmp0 (_tmp0_, "") == 0) {
		return;
	}
	_tmp1_ = self->priv->readFilename;
	_tmp2_ = fopen (_tmp1_, "r");
	readFile = _tmp2_;
	_tmp3_ = readFile;
	if (_tmp3_ == NULL) {
		FILE* _tmp4_;
		const gchar* _tmp5_;
		_tmp4_ = stderr;
		_tmp5_ = self->priv->readFilename;
		fprintf (_tmp4_, "Could not load initial memory from file \"%s\".\n", _tmp5_);
		_fclose0 (readFile);
		return;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				gint _tmp9_;
				guint64 _tmp10_;
				FILE* _tmp11_;
				gint _tmp12_ = 0;
				gint byte;
				gint _tmp13_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp9_ = i;
				_tmp10_ = self->priv->memorySizeBytes;
				if (!(((guint64) _tmp9_) < _tmp10_)) {
					break;
				}
				_tmp11_ = readFile;
				_tmp12_ = fgetc (_tmp11_);
				byte = _tmp12_;
				_tmp13_ = byte;
				if (_tmp13_ != (-1)) {
					gchar* _tmp14_;
					gint _tmp15_;
					gint _tmp16_;
					gchar _tmp17_;
					_tmp14_ = self->priv->memory;
					_tmp15_ = i;
					_tmp16_ = byte;
					_tmp14_[_tmp15_] = (gchar) _tmp16_;
					_tmp17_ = _tmp14_[_tmp15_];
				} else {
					break;
				}
			}
		}
	}
	_fclose0 (readFile);
}


static void memory_component_state_write_file (MemoryComponentState* self) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	FILE* _tmp2_ = NULL;
	FILE* writeFile;
	FILE* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->writeFilename;
	if (g_strcmp0 (_tmp0_, "") == 0) {
		return;
	}
	_tmp1_ = self->priv->writeFilename;
	_tmp2_ = fopen (_tmp1_, "w");
	writeFile = _tmp2_;
	_tmp3_ = writeFile;
	if (_tmp3_ == NULL) {
		FILE* _tmp4_;
		const gchar* _tmp5_;
		_tmp4_ = stderr;
		_tmp5_ = self->priv->writeFilename;
		fprintf (_tmp4_, "Could not save final memory to file \"%s\".\n", _tmp5_);
		_fclose0 (writeFile);
		return;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				gint _tmp9_;
				guint64 _tmp10_;
				FILE* _tmp11_;
				gchar* _tmp12_;
				gint _tmp13_;
				gchar _tmp14_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp9_ = i;
				_tmp10_ = self->priv->memorySizeBytes;
				if (!(((guint64) _tmp9_) < _tmp10_)) {
					break;
				}
				_tmp11_ = writeFile;
				_tmp12_ = self->priv->memory;
				_tmp13_ = i;
				_tmp14_ = _tmp12_[_tmp13_];
				fputc (_tmp14_, _tmp11_);
			}
		}
	}
	_fclose0 (writeFile);
}


/**
 * Allocates memory. Returns non 0 on failure.
 */
static gint memory_component_state_allocate_memory (MemoryComponentState* self) {
	gint result = 0;
	guint64 _tmp0_;
	gulong _tmp1_;
	guint64 _tmp9_;
	void* _tmp10_ = NULL;
	gchar* _tmp11_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->memorySizeBytes;
	_tmp1_ = G_MAXSIZE;
	if (_tmp0_ > ((guint64) _tmp1_)) {
		FILE* _tmp2_;
		guint64 _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gulong _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		_tmp2_ = stderr;
		_tmp3_ = self->priv->memorySizeBytes;
		_tmp4_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = G_MAXSIZE;
		_tmp7_ = g_strdup_printf ("%lu", _tmp6_);
		_tmp8_ = _tmp7_;
		fprintf (_tmp2_, "The memory block cannot be allocated (%s in %s).\n", _tmp5_, _tmp8_);
		_g_free0 (_tmp8_);
		_g_free0 (_tmp5_);
		result = 2;
		return result;
	}
	_tmp9_ = self->priv->memorySizeBytes;
	_tmp10_ = g_try_malloc0 ((gsize) _tmp9_);
	self->priv->memory = _tmp10_;
	_tmp11_ = self->priv->memory;
	if (_tmp11_ == NULL) {
		FILE* _tmp12_;
		guint64 _tmp13_;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_;
		_tmp12_ = stderr;
		_tmp13_ = self->priv->memorySizeBytes;
		_tmp14_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp13_);
		_tmp15_ = _tmp14_;
		fprintf (_tmp12_, "There is not enough free host memory to create this memory block (%s)." \
"\n", _tmp15_);
		_g_free0 (_tmp15_);
		result = 1;
		return result;
	} else {
		result = 0;
		return result;
	}
}


/**
 * Returns the bit value of the specified bit of the word at the
 * given address.
 */
static gboolean memory_component_state_get_memory (MemoryComponentState* self, guint address, guint bit) {
	gboolean result = FALSE;
	guint _tmp0_;
	guint _tmp1_;
	guint _tmp2_;
	guint _tmp3_;
	guint memoryLocation;
	guint _tmp4_;
	guint byteNumber;
	guint _tmp5_;
	guint bitNumber;
	gchar* _tmp6_;
	guint _tmp7_;
	gchar _tmp8_;
	gchar byte;
	gchar _tmp9_;
	guint _tmp10_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = address;
	_tmp1_ = self->priv->width;
	_tmp2_ = self->priv->width;
	_tmp3_ = bit;
	memoryLocation = (_tmp0_ * _tmp1_) + ((_tmp2_ - _tmp3_) - 1);
	_tmp4_ = memoryLocation;
	byteNumber = _tmp4_ / 8;
	_tmp5_ = memoryLocation;
	bitNumber = 7 - (_tmp5_ % 8);
	_tmp6_ = self->priv->memory;
	_tmp7_ = byteNumber;
	_tmp8_ = _tmp6_[_tmp7_];
	byte = _tmp8_;
	_tmp9_ = byte;
	_tmp10_ = bitNumber;
	if (((_tmp9_ >> _tmp10_) & 1) == ((guint) 1)) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


/**
 * Sets the bit value of the specified bit of the word at the given
 * address to //bitValue//.
 */
static void memory_component_state_set_memory (MemoryComponentState* self, guint address, guint bit, gboolean bitValue) {
	guint _tmp0_;
	guint _tmp1_;
	guint _tmp2_;
	guint _tmp3_;
	guint memoryLocation;
	guint _tmp4_;
	guint byteNumber;
	guint _tmp5_;
	guint bitNumber;
	gboolean _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = address;
	_tmp1_ = self->priv->width;
	_tmp2_ = self->priv->width;
	_tmp3_ = bit;
	memoryLocation = (_tmp0_ * _tmp1_) + ((_tmp2_ - _tmp3_) - 1);
	_tmp4_ = memoryLocation;
	byteNumber = _tmp4_ / 8;
	_tmp5_ = memoryLocation;
	bitNumber = 7 - (_tmp5_ % 8);
	_tmp6_ = bitValue;
	if (_tmp6_) {
		gchar* _tmp7_;
		guint _tmp8_;
		guint _tmp9_;
		gchar _tmp10_;
		_tmp7_ = self->priv->memory;
		_tmp8_ = byteNumber;
		_tmp9_ = bitNumber;
		_tmp7_[_tmp8_] |= (gchar) (1 << _tmp9_);
		_tmp10_ = _tmp7_[_tmp8_];
	} else {
		gchar* _tmp11_;
		guint _tmp12_;
		guint _tmp13_;
		gchar _tmp14_;
		_tmp11_ = self->priv->memory;
		_tmp12_ = byteNumber;
		_tmp13_ = bitNumber;
		_tmp11_[_tmp12_] &= ~((gchar) (1 << _tmp13_));
		_tmp14_ = _tmp11_[_tmp12_];
	}
}


static void memory_component_state_real_update (ComponentState* base) {
	MemoryComponentState * self;
	guint address;
	gchar* _tmp0_;
	Connection* _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp54_ = FALSE;
	Connection* _tmp55_;
	gboolean _tmp56_;
	gboolean _tmp57_;
	gboolean _tmp64_;
	Connection* _tmp73_;
	gboolean _tmp74_;
	gboolean _tmp75_;
	self = (MemoryComponentState*) base;
	address = (guint) 0;
	_tmp0_ = self->priv->memory;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = self->priv->selectWire;
	_tmp2_ = connection_get_signalState (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_) {
		Connection* _tmp16_;
		gboolean _tmp17_;
		gboolean _tmp18_;
		gboolean _tmp37_ = FALSE;
		Connection* _tmp38_;
		gboolean _tmp39_;
		gboolean _tmp40_;
		gboolean _tmp42_;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					gboolean _tmp5_;
					gint _tmp7_;
					Connection** _tmp8_;
					gint _tmp8__length1;
					Connection** _tmp9_;
					gint _tmp9__length1;
					gint _tmp10_;
					Connection* _tmp11_;
					gboolean _tmp12_;
					gboolean _tmp13_;
					_tmp5_ = _tmp4_;
					if (!_tmp5_) {
						gint _tmp6_;
						_tmp6_ = i;
						i = _tmp6_ + 1;
					}
					_tmp4_ = FALSE;
					_tmp7_ = i;
					_tmp8_ = self->priv->addressWires;
					_tmp8__length1 = self->priv->addressWires_length1;
					if (!(_tmp7_ < _tmp8__length1)) {
						break;
					}
					_tmp9_ = self->priv->addressWires;
					_tmp9__length1 = self->priv->addressWires_length1;
					_tmp10_ = i;
					_tmp11_ = _tmp9_[_tmp10_];
					_tmp12_ = connection_get_signalState (_tmp11_);
					_tmp13_ = _tmp12_;
					if (_tmp13_) {
						guint _tmp14_;
						gint _tmp15_;
						_tmp14_ = address;
						_tmp15_ = i;
						address = _tmp14_ + (1 << _tmp15_);
					}
				}
			}
		}
		_tmp16_ = self->priv->writeEnableWire;
		_tmp17_ = connection_get_signalState (_tmp16_);
		_tmp18_ = _tmp17_;
		if (_tmp18_) {
			gboolean _tmp19_ = FALSE;
			Connection* _tmp20_;
			gboolean _tmp21_;
			gboolean _tmp22_;
			gboolean _tmp24_;
			_tmp20_ = self->priv->clockWire;
			_tmp21_ = connection_get_signalState (_tmp20_);
			_tmp22_ = _tmp21_;
			if (_tmp22_) {
				gboolean _tmp23_;
				_tmp23_ = self->priv->previousClockSignal;
				_tmp19_ = !_tmp23_;
			} else {
				_tmp19_ = FALSE;
			}
			_tmp24_ = _tmp19_;
			if (_tmp24_) {
				{
					guint i;
					i = (guint) 0;
					{
						gboolean _tmp25_;
						_tmp25_ = TRUE;
						while (TRUE) {
							gboolean _tmp26_;
							guint _tmp28_;
							guint _tmp29_;
							guint _tmp30_;
							guint _tmp31_;
							Connection** _tmp32_;
							gint _tmp32__length1;
							guint _tmp33_;
							Connection* _tmp34_;
							gboolean _tmp35_;
							gboolean _tmp36_;
							_tmp26_ = _tmp25_;
							if (!_tmp26_) {
								guint _tmp27_;
								_tmp27_ = i;
								i = _tmp27_ + 1;
							}
							_tmp25_ = FALSE;
							_tmp28_ = i;
							_tmp29_ = self->priv->width;
							if (!(_tmp28_ < _tmp29_)) {
								break;
							}
							_tmp30_ = address;
							_tmp31_ = i;
							_tmp32_ = self->priv->dataWires;
							_tmp32__length1 = self->priv->dataWires_length1;
							_tmp33_ = i;
							_tmp34_ = _tmp32_[_tmp33_];
							_tmp35_ = connection_get_signalState (_tmp34_);
							_tmp36_ = _tmp35_;
							memory_component_state_set_memory (self, _tmp30_, _tmp31_, _tmp36_);
						}
					}
				}
			}
		}
		_tmp38_ = self->priv->readEnableWire;
		_tmp39_ = connection_get_signalState (_tmp38_);
		_tmp40_ = _tmp39_;
		if (_tmp40_) {
			_tmp37_ = TRUE;
		} else {
			MemoryComponentStateMemoryType _tmp41_;
			_tmp41_ = self->priv->memoryType;
			_tmp37_ = _tmp41_ == MEMORY_COMPONENT_STATE_MEMORY_TYPE_ROM_CS;
		}
		_tmp42_ = _tmp37_;
		if (_tmp42_) {
			{
				guint i;
				i = (guint) 0;
				{
					gboolean _tmp43_;
					_tmp43_ = TRUE;
					while (TRUE) {
						gboolean _tmp44_;
						guint _tmp46_;
						guint _tmp47_;
						Connection** _tmp48_;
						gint _tmp48__length1;
						guint _tmp49_;
						Connection* _tmp50_;
						guint _tmp51_;
						guint _tmp52_;
						gboolean _tmp53_ = FALSE;
						_tmp44_ = _tmp43_;
						if (!_tmp44_) {
							guint _tmp45_;
							_tmp45_ = i;
							i = _tmp45_ + 1;
						}
						_tmp43_ = FALSE;
						_tmp46_ = i;
						_tmp47_ = self->priv->width;
						if (!(_tmp46_ < _tmp47_)) {
							break;
						}
						_tmp48_ = self->priv->dataWires;
						_tmp48__length1 = self->priv->dataWires_length1;
						_tmp49_ = i;
						_tmp50_ = _tmp48_[_tmp49_];
						_tmp51_ = address;
						_tmp52_ = i;
						_tmp53_ = memory_component_state_get_memory (self, _tmp51_, _tmp52_);
						connection_set_signalState (_tmp50_, _tmp53_);
					}
				}
			}
		}
	}
	_tmp55_ = self->priv->selectWire;
	_tmp56_ = connection_get_signalState (_tmp55_);
	_tmp57_ = _tmp56_;
	if (!_tmp57_) {
		_tmp54_ = TRUE;
	} else {
		gboolean _tmp58_ = FALSE;
		Connection* _tmp59_;
		gboolean _tmp60_;
		gboolean _tmp61_;
		gboolean _tmp63_;
		_tmp59_ = self->priv->readEnableWire;
		_tmp60_ = connection_get_signalState (_tmp59_);
		_tmp61_ = _tmp60_;
		if (!_tmp61_) {
			MemoryComponentStateMemoryType _tmp62_;
			_tmp62_ = self->priv->memoryType;
			_tmp58_ = _tmp62_ == MEMORY_COMPONENT_STATE_MEMORY_TYPE_RAM_CS_RE_WE;
		} else {
			_tmp58_ = FALSE;
		}
		_tmp63_ = _tmp58_;
		_tmp54_ = _tmp63_;
	}
	_tmp64_ = _tmp54_;
	if (_tmp64_) {
		{
			guint i;
			i = (guint) 0;
			{
				gboolean _tmp65_;
				_tmp65_ = TRUE;
				while (TRUE) {
					gboolean _tmp66_;
					guint _tmp68_;
					guint _tmp69_;
					Connection** _tmp70_;
					gint _tmp70__length1;
					guint _tmp71_;
					Connection* _tmp72_;
					_tmp66_ = _tmp65_;
					if (!_tmp66_) {
						guint _tmp67_;
						_tmp67_ = i;
						i = _tmp67_ + 1;
					}
					_tmp65_ = FALSE;
					_tmp68_ = i;
					_tmp69_ = self->priv->width;
					if (!(_tmp68_ < _tmp69_)) {
						break;
					}
					_tmp70_ = self->priv->dataWires;
					_tmp70__length1 = self->priv->dataWires_length1;
					_tmp71_ = i;
					_tmp72_ = _tmp70_[_tmp71_];
					connection_disable_signal (_tmp72_);
				}
			}
		}
	}
	_tmp73_ = self->priv->clockWire;
	_tmp74_ = connection_get_signalState (_tmp73_);
	_tmp75_ = _tmp74_;
	self->priv->previousClockSignal = _tmp75_;
}


static void memory_component_state_class_init (MemoryComponentStateClass * klass) {
	memory_component_state_parent_class = g_type_class_peek_parent (klass);
	COMPONENT_STATE_CLASS (klass)->finalize = memory_component_state_finalize;
	g_type_class_add_private (klass, sizeof (MemoryComponentStatePrivate));
	COMPONENT_STATE_CLASS (klass)->update = memory_component_state_real_update;
}


static void memory_component_state_instance_init (MemoryComponentState * self) {
	self->priv = MEMORY_COMPONENT_STATE_GET_PRIVATE (self);
}


static void memory_component_state_finalize (ComponentState* obj) {
	MemoryComponentState * self;
	gchar* _tmp0_;
	self = MEMORY_COMPONENT_STATE (obj);
	memory_component_state_write_file (self);
	_tmp0_ = self->priv->memory;
	g_free (_tmp0_);
	self->priv->addressWires = (_vala_array_free (self->priv->addressWires, self->priv->addressWires_length1, (GDestroyNotify) connection_unref), NULL);
	self->priv->dataWires = (_vala_array_free (self->priv->dataWires, self->priv->dataWires_length1, (GDestroyNotify) connection_unref), NULL);
	_connection_unref0 (self->priv->selectWire);
	_connection_unref0 (self->priv->readEnableWire);
	_connection_unref0 (self->priv->writeEnableWire);
	_connection_unref0 (self->priv->clockWire);
	_g_free0 (self->priv->readFilename);
	_g_free0 (self->priv->writeFilename);
	COMPONENT_STATE_CLASS (memory_component_state_parent_class)->finalize (obj);
}


GType memory_component_state_get_type (void) {
	static volatile gsize memory_component_state_type_id__volatile = 0;
	if (g_once_init_enter (&memory_component_state_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MemoryComponentStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) memory_component_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MemoryComponentState), 0, (GInstanceInitFunc) memory_component_state_instance_init, NULL };
		GType memory_component_state_type_id;
		memory_component_state_type_id = g_type_register_static (TYPE_COMPONENT_STATE, "MemoryComponentState", &g_define_type_info, 0);
		g_once_init_leave (&memory_component_state_type_id__volatile, memory_component_state_type_id);
	}
	return memory_component_state_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



