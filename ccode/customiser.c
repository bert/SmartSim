/* customiser.c generated by valac 0.16.0, the Vala compiler
 * generated from customiser.vala, do not modify */

/* 
 * SmartSim - Digital Logic Circuit Designer and Simulator
 *   
 *   Expansion Version
 *   
 *   Filename: customiser.vala
 *   
 *   Copyright Ashley Newson 2012
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <cairo.h>
#include <libxml/tree.h>
#include <libxml/xmlwriter.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_CUSTOMISER (customiser_get_type ())
#define CUSTOMISER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOMISER, Customiser))
#define CUSTOMISER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOMISER, CustomiserClass))
#define IS_CUSTOMISER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOMISER))
#define IS_CUSTOMISER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOMISER))
#define CUSTOMISER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOMISER, CustomiserClass))

typedef struct _Customiser Customiser;
typedef struct _CustomiserClass CustomiserClass;
typedef struct _CustomiserPrivate CustomiserPrivate;

#define TYPE_COMPONENT_DEF (component_def_get_type ())
#define COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_DEF, ComponentDef))
#define COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_DEF, ComponentDefClass))
#define IS_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_DEF))
#define IS_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_DEF))
#define COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_DEF, ComponentDefClass))

typedef struct _ComponentDef ComponentDef;
typedef struct _ComponentDefClass ComponentDefClass;

#define TYPE_CUSTOM_COMPONENT_DEF (custom_component_def_get_type ())
#define CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDef))
#define CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))
#define IS_CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_COMPONENT_DEF))
#define IS_CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOM_COMPONENT_DEF))
#define CUSTOM_COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))

typedef struct _CustomComponentDef CustomComponentDef;
typedef struct _CustomComponentDefClass CustomComponentDefClass;

#define TYPE_DESIGNER_WINDOW (designer_window_get_type ())
#define DESIGNER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DESIGNER_WINDOW, DesignerWindow))
#define DESIGNER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DESIGNER_WINDOW, DesignerWindowClass))
#define IS_DESIGNER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DESIGNER_WINDOW))
#define IS_DESIGNER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DESIGNER_WINDOW))
#define DESIGNER_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DESIGNER_WINDOW, DesignerWindowClass))

typedef struct _DesignerWindow DesignerWindow;
typedef struct _DesignerWindowClass DesignerWindowClass;

#define TYPE_PROJECT (project_get_type ())
#define PROJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROJECT, Project))
#define PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROJECT, ProjectClass))
#define IS_PROJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROJECT))
#define IS_PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROJECT))
#define PROJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROJECT, ProjectClass))

typedef struct _Project Project;
typedef struct _ProjectClass ProjectClass;

#define TYPE_PIN_DEF (pin_def_get_type ())
#define PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PIN_DEF, PinDef))
#define PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PIN_DEF, PinDefClass))
#define IS_PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PIN_DEF))
#define IS_PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PIN_DEF))
#define PIN_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PIN_DEF, PinDefClass))

typedef struct _PinDef PinDef;
typedef struct _PinDefClass PinDefClass;

#define TYPE_TAG (tag_get_type ())
#define TAG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TAG, Tag))
#define TAG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TAG, TagClass))
#define IS_TAG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TAG))
#define IS_TAG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TAG))
#define TAG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TAG, TagClass))

typedef struct _Tag Tag;
typedef struct _TagClass TagClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _component_def_unref0(var) ((var == NULL) ? NULL : (var = (component_def_unref (var), NULL)))
#define _project_unref0(var) ((var == NULL) ? NULL : (var = (project_unref (var), NULL)))
#define _pin_def_unref0(var) ((var == NULL) ? NULL : (var = (pin_def_unref (var), NULL)))
#define _tag_unref0(var) ((var == NULL) ? NULL : (var = (tag_unref (var), NULL)))
typedef struct _ComponentDefPrivate ComponentDefPrivate;

#define TYPE_DIRECTION (direction_get_type ())

#define TYPE_COMPONENT_INST (component_inst_get_type ())
#define COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_INST, ComponentInst))
#define COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_INST, ComponentInstClass))
#define IS_COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_INST))
#define IS_COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_INST))
#define COMPONENT_INST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_INST, ComponentInstClass))

typedef struct _ComponentInst ComponentInst;
typedef struct _ComponentInstClass ComponentInstClass;

#define TYPE_PROPERTY_ITEM (property_item_get_type ())
#define PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_ITEM, PropertyItem))
#define PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_ITEM, PropertyItemClass))
#define IS_PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_ITEM))
#define IS_PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_ITEM))
#define PROPERTY_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_ITEM, PropertyItemClass))

typedef struct _PropertyItem PropertyItem;
typedef struct _PropertyItemClass PropertyItemClass;

#define TYPE_PROPERTY_SET (property_set_get_type ())
#define PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_SET, PropertySet))
#define PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_SET, PropertySetClass))
#define IS_PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_SET))
#define IS_PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_SET))
#define PROPERTY_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_SET, PropertySetClass))

typedef struct _PropertySet PropertySet;
typedef struct _PropertySetClass PropertySetClass;

#define TYPE_COMPILED_CIRCUIT (compiled_circuit_get_type ())
#define COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuit))
#define COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))
#define IS_COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPILED_CIRCUIT))
#define IS_COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPILED_CIRCUIT))
#define COMPILED_CIRCUIT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))

typedef struct _CompiledCircuit CompiledCircuit;
typedef struct _CompiledCircuitClass CompiledCircuitClass;

#define TYPE_CONNECTION (connection_get_type ())
#define CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONNECTION, Connection))
#define CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONNECTION, ConnectionClass))
#define IS_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONNECTION))
#define IS_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONNECTION))
#define CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONNECTION, ConnectionClass))

typedef struct _Connection Connection;
typedef struct _ConnectionClass ConnectionClass;

#define TYPE_CIRCUIT_INFORMATION (circuit_information_get_type ())
#define CIRCUIT_INFORMATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CIRCUIT_INFORMATION, CircuitInformation))
#define CIRCUIT_INFORMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CIRCUIT_INFORMATION, CircuitInformationClass))
#define IS_CIRCUIT_INFORMATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CIRCUIT_INFORMATION))
#define IS_CIRCUIT_INFORMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CIRCUIT_INFORMATION))
#define CIRCUIT_INFORMATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CIRCUIT_INFORMATION, CircuitInformationClass))

typedef struct _CircuitInformation CircuitInformation;
typedef struct _CircuitInformationClass CircuitInformationClass;

#define TYPE_GRAPHIC (graphic_get_type ())
#define GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GRAPHIC, Graphic))
#define GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GRAPHIC, GraphicClass))
#define IS_GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GRAPHIC))
#define IS_GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GRAPHIC))
#define GRAPHIC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GRAPHIC, GraphicClass))

typedef struct _Graphic Graphic;
typedef struct _GraphicClass GraphicClass;
typedef struct _TagPrivate TagPrivate;

#define TYPE_FLOW (flow_get_type ())

#define PIN_DEF_TYPE_LABEL_TYPE (pin_def_label_type_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _PinDefPrivate PinDefPrivate;
typedef struct _DesignerWindowPrivate DesignerWindowPrivate;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
typedef struct _ParamSpecCustomiser ParamSpecCustomiser;

struct _Customiser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	CustomiserPrivate * priv;
};

struct _CustomiserClass {
	GTypeClass parent_class;
	void (*finalize) (Customiser *self);
};

struct _CustomiserPrivate {
	GtkDialog* dialog;
	GtkHBox* layoutHBox;
	GtkEventBox* controller;
	GtkDrawingArea* display;
	GtkVBox* controlsVBox;
	GtkHBox* nameHBox;
	GtkEntry* nameEntry;
	GtkLabel* nameLabel;
	GtkHBox* descriptionHBox;
	GtkEntry* descriptionEntry;
	GtkLabel* descriptionLabel;
	GtkHBox* labelHBox;
	GtkEntry* labelEntry;
	GtkLabel* labelLabel;
	GtkHBox* pinHBox;
	GtkSpinButton* pinSpinButton;
	GtkLabel* pinLabel;
	GtkLabel* tagNameLabel;
	GtkCheckButton* requiredCheck;
	GtkVBox* labelTypeVBox;
	GtkLabel* labelTypeLabel;
	GtkRadioButton* labelTypeNoneRadio;
	GtkRadioButton* labelTypeTextRadio;
	GtkRadioButton* labelTypeTextBarRadio;
	GtkRadioButton* labelTypeClockRadio;
	GtkHBox* pinLabelHBox;
	GtkEntry* pinLabelEntry;
	GtkLabel* pinLabelLabel;
	GtkLabel* boundsLabel;
	GtkTable* boundsTable;
	GtkLabel* rightBoundLabel;
	GtkSpinButton* rightBoundSpinButton;
	GtkLabel* downBoundLabel;
	GtkSpinButton* downBoundSpinButton;
	GtkLabel* leftBoundLabel;
	GtkSpinButton* leftBoundSpinButton;
	GtkLabel* upBoundLabel;
	GtkSpinButton* upBoundSpinButton;
	GtkButton* colourButton;
	GtkButton* closeButton;
	cairo_surface_t* gridCache;
	CustomComponentDef* customComponentDef;
	DesignerWindow* parent;
	Project* project;
	gint selectedPinID;
	PinDef* selectedPin;
	gint xMouseStart;
	gint yMouseStart;
	Tag* tag;
};

typedef enum  {
	DIRECTION_NONE,
	DIRECTION_RIGHT,
	DIRECTION_DOWN,
	DIRECTION_LEFT,
	DIRECTION_UP,
	DIRECTION_HORIZONTAL,
	DIRECTION_VERTICAL,
	DIRECTION_DIAGONAL
} Direction;

struct _ComponentDef {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ComponentDefPrivate * priv;
	Graphic* graphic;
	gchar* name;
	gchar* description;
	gchar* iconFilename;
	gchar* label;
	PinDef** pinDefs;
	gint pinDefs_length1;
	gint rightBound;
	gint downBound;
	gint leftBound;
	gint upBound;
	gint backgroundAlpha;
	gint backgroundRed;
	gint backgroundGreen;
	gint backgroundBlue;
	gdouble backgroundAlphaF;
	gdouble backgroundRedF;
	gdouble backgroundGreenF;
	gdouble backgroundBlueF;
	gboolean drawBox;
	gchar* filename;
};

struct _ComponentDefClass {
	GTypeClass parent_class;
	void (*finalize) (ComponentDef *self);
	void (*extra_render) (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst);
	void (*add_properties) (ComponentDef* self, PropertySet* queryProperty, PropertySet* configurationProperty);
	void (*get_properties) (ComponentDef* self, PropertySet* queryProperty, PropertySet** configurationProperty);
	void (*load_properties) (ComponentDef* self, xmlNode* xmlnode, PropertySet** configurationProperty);
	void (*save_properties) (ComponentDef* self, xmlTextWriter* xmlWriter, PropertySet* configurationProperty);
	void (*configure_inst) (ComponentDef* self, ComponentInst* componentInst, gboolean firstLoad);
	void (*compile_component) (ComponentDef* self, CompiledCircuit* compiledCircuit, ComponentInst* componentInst, Connection** connections, int connections_length1, ComponentInst** ancestry, int ancestry_length1);
	void (*create_information) (ComponentDef* self, CircuitInformation* circuitInformation);
};

typedef enum  {
	FLOW_NONE,
	FLOW_IN,
	FLOW_OUT,
	FLOW_BIDIRECTIONAL
} Flow;

struct _Tag {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TagPrivate * priv;
	gchar* text;
	gint xTag;
	gint yTag;
	gint xWire;
	gint yWire;
	gint pinid;
	Flow flow;
	Direction direction;
	gint rightBound;
	gint downBound;
	gint leftBound;
	gint upBound;
};

struct _TagClass {
	GTypeClass parent_class;
	void (*finalize) (Tag *self);
};

typedef enum  {
	PIN_DEF_LABEL_TYPE_NONE,
	PIN_DEF_LABEL_TYPE_TEXT,
	PIN_DEF_LABEL_TYPE_TEXTBAR,
	PIN_DEF_LABEL_TYPE_CLOCK
} PinDefLabelType;

struct _PinDef {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PinDefPrivate * priv;
	gint x;
	gint y;
	gint xLabel;
	gint yLabel;
	gint xConnect;
	gint yConnect;
	Direction direction;
	gint length;
	gboolean array;
	Flow flow;
	gint defaultArraySize;
	gint idealSpace;
	gfloat minSpace;
	gchar* label;
	gboolean required;
	gboolean userArrayResize;
	gboolean showDefault;
	PinDefLabelType labelType;
};

struct _PinDefClass {
	GTypeClass parent_class;
	void (*finalize) (PinDef *self);
};

struct _DesignerWindow {
	GtkWindow parent_instance;
	DesignerWindowPrivate * priv;
	gint myID;
	gchar* componentFileName;
	gint gridSize;
	gfloat zoom;
	gboolean showGrid;
	gboolean liveScrollUpdate;
	gboolean shadowComponent;
};

struct _DesignerWindowClass {
	GtkWindowClass parent_class;
};

struct _ParamSpecCustomiser {
	GParamSpec parent_instance;
};


static gpointer customiser_parent_class = NULL;

gpointer customiser_ref (gpointer instance);
void customiser_unref (gpointer instance);
GParamSpec* param_spec_customiser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_customiser (GValue* value, gpointer v_object);
void value_take_customiser (GValue* value, gpointer v_object);
gpointer value_get_customiser (const GValue* value);
GType customiser_get_type (void) G_GNUC_CONST;
gpointer component_def_ref (gpointer instance);
void component_def_unref (gpointer instance);
GParamSpec* param_spec_component_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_def (GValue* value, gpointer v_object);
void value_take_component_def (GValue* value, gpointer v_object);
gpointer value_get_component_def (const GValue* value);
GType component_def_get_type (void) G_GNUC_CONST;
GType custom_component_def_get_type (void) G_GNUC_CONST;
GType designer_window_get_type (void) G_GNUC_CONST;
gpointer project_ref (gpointer instance);
void project_unref (gpointer instance);
GParamSpec* param_spec_project (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_project (GValue* value, gpointer v_object);
void value_take_project (GValue* value, gpointer v_object);
gpointer value_get_project (const GValue* value);
GType project_get_type (void) G_GNUC_CONST;
gpointer pin_def_ref (gpointer instance);
void pin_def_unref (gpointer instance);
GParamSpec* param_spec_pin_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_pin_def (GValue* value, gpointer v_object);
void value_take_pin_def (GValue* value, gpointer v_object);
gpointer value_get_pin_def (const GValue* value);
GType pin_def_get_type (void) G_GNUC_CONST;
gpointer tag_ref (gpointer instance);
void tag_unref (gpointer instance);
GParamSpec* param_spec_tag (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_tag (GValue* value, gpointer v_object);
void value_take_tag (GValue* value, gpointer v_object);
gpointer value_get_tag (const GValue* value);
GType tag_get_type (void) G_GNUC_CONST;
#define CUSTOMISER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CUSTOMISER, CustomiserPrivate))
enum  {
	CUSTOMISER_DUMMY_PROPERTY
};
Customiser* customiser_new (DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project);
Customiser* customiser_construct (GType object_type, DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project);
gint custom_component_def_count_tags (CustomComponentDef* self);
GType direction_get_type (void) G_GNUC_CONST;
gpointer component_inst_ref (gpointer instance);
void component_inst_unref (gpointer instance);
GParamSpec* param_spec_component_inst (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_inst (GValue* value, gpointer v_object);
void value_take_component_inst (GValue* value, gpointer v_object);
gpointer value_get_component_inst (const GValue* value);
GType component_inst_get_type (void) G_GNUC_CONST;
gpointer property_item_ref (gpointer instance);
void property_item_unref (gpointer instance);
GParamSpec* param_spec_property_item (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_property_item (GValue* value, gpointer v_object);
void value_take_property_item (GValue* value, gpointer v_object);
gpointer value_get_property_item (const GValue* value);
GType property_item_get_type (void) G_GNUC_CONST;
GType property_set_get_type (void) G_GNUC_CONST;
gpointer compiled_circuit_ref (gpointer instance);
void compiled_circuit_unref (gpointer instance);
GParamSpec* param_spec_compiled_circuit (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_compiled_circuit (GValue* value, gpointer v_object);
void value_take_compiled_circuit (GValue* value, gpointer v_object);
gpointer value_get_compiled_circuit (const GValue* value);
GType compiled_circuit_get_type (void) G_GNUC_CONST;
gpointer connection_ref (gpointer instance);
void connection_unref (gpointer instance);
GParamSpec* param_spec_connection (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_connection (GValue* value, gpointer v_object);
void value_take_connection (GValue* value, gpointer v_object);
gpointer value_get_connection (const GValue* value);
GType connection_get_type (void) G_GNUC_CONST;
gpointer circuit_information_ref (gpointer instance);
void circuit_information_unref (gpointer instance);
GParamSpec* param_spec_circuit_information (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_circuit_information (GValue* value, gpointer v_object);
void value_take_circuit_information (GValue* value, gpointer v_object);
gpointer value_get_circuit_information (const GValue* value);
GType circuit_information_get_type (void) G_GNUC_CONST;
gpointer graphic_ref (gpointer instance);
void graphic_unref (gpointer instance);
GParamSpec* param_spec_graphic (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_graphic (GValue* value, gpointer v_object);
void value_take_graphic (GValue* value, gpointer v_object);
gpointer value_get_graphic (const GValue* value);
GType graphic_get_type (void) G_GNUC_CONST;
Tag* custom_component_def_resolve_tag_id (CustomComponentDef* self, gint tagID);
GType flow_get_type (void) G_GNUC_CONST;
GType pin_def_label_type_get_type (void) G_GNUC_CONST;
PinDef* pin_def_new (gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault);
PinDef* pin_def_construct (GType object_type, gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault);
gint custom_component_def_validate_interfaces (CustomComponentDef* self);
void basic_dialog_warning (GtkWindow* window, const gchar* text);
static void customiser_populate (Customiser* self);
void customiser_update_selection (Customiser* self);
static gboolean customiser_mouse_down (Customiser* self, GdkEventButton* event);
static gboolean _customiser_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean customiser_mouse_up (Customiser* self, GdkEventButton* event);
static gboolean _customiser_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean __lambda53_ (Customiser* self);
gboolean customiser_render_def (Customiser* self);
static gboolean ___lambda53__gtk_widget_expose_event (GtkWidget* _sender, GdkEventExpose* event, gpointer self);
static gboolean __lambda54_ (Customiser* self);
static gboolean ___lambda54__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
static void __lambda55_ (Customiser* self);
static void ___lambda55__gtk_editable_changed (GtkEditable* _sender, gpointer self);
static void _customiser_update_selection_gtk_editable_changed (GtkEditable* _sender, gpointer self);
static void ___lambda56_ (Customiser* self);
static void ____lambda56__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
void customiser_update_label_type (Customiser* self);
static void _customiser_update_label_type_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void ___lambda57_ (Customiser* self);
static void ____lambda57__gtk_editable_changed (GtkEditable* _sender, gpointer self);
void customiser_update_bounds (Customiser* self);
static void _customiser_update_bounds_gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self);
static void __lambda58_ (Customiser* self);
void customiser_set_colour (Customiser* self);
static void ___lambda58__gtk_button_clicked (GtkButton* _sender, gpointer self);
void customiser_response_handler (Customiser* self, gint response_id);
static void _customiser_response_handler_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
void pin_def_set_position (PinDef* self, gint x, gint y, gint length, Direction direction);
void customiser_update_values (Customiser* self);
void customiser_run (Customiser* self);
ComponentDef* project_resolve_def_name (Project* self, const gchar* name);
void basic_dialog_error (GtkWindow* window, const gchar* text);
void component_def_render (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst, gboolean colourBackground);
void pin_def_render (PinDef* self, cairo_t* context, gboolean invert);
static void customiser_finalize (Customiser* obj);


/**
 * Start the customiser, setting the caller DesignerWindow, target 
 * custom component and its project.
 */
static gpointer _component_def_ref0 (gpointer self) {
	return self ? component_def_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _project_ref0 (gpointer self) {
	return self ? project_ref (self) : NULL;
}


Customiser* customiser_construct (GType object_type, DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project) {
	Customiser* self = NULL;
	CustomComponentDef* _tmp0_;
	CustomComponentDef* _tmp1_;
	DesignerWindow* _tmp2_;
	DesignerWindow* _tmp3_;
	Project* _tmp4_;
	Project* _tmp5_;
	CustomComponentDef* _tmp6_;
	gint _tmp7_ = 0;
	gint tagCount;
	CustomComponentDef* _tmp8_;
	gint _tmp9_;
	gint _tmp10_ = 0;
	CustomComponentDef* _tmp36_;
	gint _tmp37_ = 0;
	g_return_val_if_fail (customComponentDef != NULL, NULL);
	g_return_val_if_fail (project != NULL, NULL);
	self = (Customiser*) g_type_create_instance (object_type);
	_tmp0_ = customComponentDef;
	_tmp1_ = _component_def_ref0 (_tmp0_);
	_component_def_unref0 (self->priv->customComponentDef);
	self->priv->customComponentDef = _tmp1_;
	_tmp2_ = parent;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp3_;
	_tmp4_ = project;
	_tmp5_ = _project_ref0 (_tmp4_);
	_project_unref0 (self->priv->project);
	self->priv->project = _tmp5_;
	_tmp6_ = customComponentDef;
	_tmp7_ = custom_component_def_count_tags (_tmp6_);
	tagCount = _tmp7_;
	_tmp8_ = customComponentDef;
	_tmp9_ = tagCount;
	_tmp10_ = _tmp9_;
	((ComponentDef*) _tmp8_)->pinDefs = g_renew (PinDef*, ((ComponentDef*) _tmp8_)->pinDefs, _tmp9_);
	(_tmp10_ > ((ComponentDef*) _tmp8_)->pinDefs_length1) ? memset (((ComponentDef*) _tmp8_)->pinDefs + ((ComponentDef*) _tmp8_)->pinDefs_length1, 0, sizeof (PinDef*) * (_tmp10_ - ((ComponentDef*) _tmp8_)->pinDefs_length1)) : NULL;
	((ComponentDef*) _tmp8_)->pinDefs_length1 = _tmp10_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp11_;
			_tmp11_ = TRUE;
			while (TRUE) {
				gboolean _tmp12_;
				gint _tmp14_;
				gint _tmp15_;
				CustomComponentDef* _tmp16_;
				PinDef** _tmp17_;
				gint _tmp17__length1;
				gint _tmp18_;
				PinDef* _tmp19_;
				_tmp12_ = _tmp11_;
				if (!_tmp12_) {
					gint _tmp13_;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp11_ = FALSE;
				_tmp14_ = i;
				_tmp15_ = tagCount;
				if (!(_tmp14_ < _tmp15_)) {
					break;
				}
				_tmp16_ = customComponentDef;
				_tmp17_ = ((ComponentDef*) _tmp16_)->pinDefs;
				_tmp17__length1 = ((ComponentDef*) _tmp16_)->pinDefs_length1;
				_tmp18_ = i;
				_tmp19_ = _tmp17_[_tmp18_];
				if (_tmp19_ == NULL) {
					CustomComponentDef* _tmp20_;
					gint _tmp21_;
					Tag* _tmp22_ = NULL;
					Tag* resolvedTag;
					Tag* _tmp23_;
					_tmp20_ = customComponentDef;
					_tmp21_ = i;
					_tmp22_ = custom_component_def_resolve_tag_id (_tmp20_, _tmp21_);
					resolvedTag = _tmp22_;
					_tmp23_ = resolvedTag;
					if (_tmp23_ != NULL) {
						CustomComponentDef* _tmp24_;
						PinDef** _tmp25_;
						gint _tmp25__length1;
						gint _tmp26_;
						Tag* _tmp27_;
						Flow _tmp28_;
						PinDef* _tmp29_;
						PinDef* _tmp30_;
						_tmp24_ = customComponentDef;
						_tmp25_ = ((ComponentDef*) _tmp24_)->pinDefs;
						_tmp25__length1 = ((ComponentDef*) _tmp24_)->pinDefs_length1;
						_tmp26_ = i;
						_tmp27_ = resolvedTag;
						_tmp28_ = _tmp27_->flow;
						_tmp29_ = pin_def_new (0, 0, DIRECTION_RIGHT, _tmp28_, 0, FALSE, 1, 0, (gfloat) 0, "", PIN_DEF_LABEL_TYPE_NONE, TRUE, TRUE, TRUE);
						_pin_def_unref0 (_tmp25_[_tmp26_]);
						_tmp25_[_tmp26_] = _tmp29_;
						_tmp30_ = _tmp25_[_tmp26_];
					} else {
						CustomComponentDef* _tmp31_;
						PinDef** _tmp32_;
						gint _tmp32__length1;
						gint _tmp33_;
						PinDef* _tmp34_;
						PinDef* _tmp35_;
						_tmp31_ = customComponentDef;
						_tmp32_ = ((ComponentDef*) _tmp31_)->pinDefs;
						_tmp32__length1 = ((ComponentDef*) _tmp31_)->pinDefs_length1;
						_tmp33_ = i;
						_tmp34_ = pin_def_new (0, 0, DIRECTION_RIGHT, FLOW_NONE, 0, FALSE, 1, 0, (gfloat) 0, "", PIN_DEF_LABEL_TYPE_NONE, TRUE, TRUE, TRUE);
						_pin_def_unref0 (_tmp32_[_tmp33_]);
						_tmp32_[_tmp33_] = _tmp34_;
						_tmp35_ = _tmp32_[_tmp33_];
					}
					_tag_unref0 (resolvedTag);
				}
			}
		}
	}
	_tmp36_ = customComponentDef;
	_tmp37_ = custom_component_def_validate_interfaces (_tmp36_);
	if (_tmp37_ != 0) {
		basic_dialog_warning (NULL, "Warning:\n" \
"Could not associate all pins with interface tags. Make sure that all t" \
"ags have unique and sequential IDs starting with 0. You can cycle thro" \
"ugh the pins to check the associations.\n");
	}
	customiser_populate (self);
	customiser_update_selection (self);
	return self;
}


Customiser* customiser_new (DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project) {
	return customiser_construct (TYPE_CUSTOMISER, parent, customComponentDef, project);
}


/**
 * Create a new Gtk Dialog and populate it with widgets
 */
static gboolean _customiser_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = customiser_mouse_down (self, event);
	return result;
}


static gboolean _customiser_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = customiser_mouse_up (self, event);
	return result;
}


static gboolean __lambda53_ (Customiser* self) {
	gboolean result = FALSE;
	customiser_render_def (self);
	result = FALSE;
	return result;
}


static gboolean ___lambda53__gtk_widget_expose_event (GtkWidget* _sender, GdkEventExpose* event, gpointer self) {
	gboolean result;
	result = __lambda53_ (self);
	return result;
}


static gboolean __lambda54_ (Customiser* self) {
	gboolean result = FALSE;
	_cairo_surface_destroy0 (self->priv->gridCache);
	self->priv->gridCache = NULL;
	customiser_render_def (self);
	result = FALSE;
	return result;
}


static gboolean ___lambda54__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = __lambda54_ (self);
	return result;
}


static void __lambda55_ (Customiser* self) {
	CustomComponentDef* _tmp0_;
	GtkEntry* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = self->priv->customComponentDef;
	_tmp1_ = self->priv->labelEntry;
	_tmp2_ = gtk_entry_get_text (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 (((ComponentDef*) _tmp0_)->label);
	((ComponentDef*) _tmp0_)->label = _tmp4_;
	customiser_render_def (self);
}


static void ___lambda55__gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	__lambda55_ (self);
}


static gpointer _pin_def_ref0 (gpointer self) {
	return self ? pin_def_ref (self) : NULL;
}


static void _customiser_update_selection_gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	customiser_update_selection (self);
}


static void ___lambda56_ (Customiser* self) {
	PinDef* _tmp0_;
	_tmp0_ = self->priv->selectedPin;
	if (_tmp0_ != NULL) {
		PinDef* _tmp1_;
		GtkCheckButton* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp1_ = self->priv->selectedPin;
		_tmp2_ = self->priv->requiredCheck;
		_tmp3_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp1_->required = _tmp4_;
	}
}


static void ____lambda56__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	___lambda56_ (self);
}


static void _customiser_update_label_type_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	customiser_update_label_type (self);
}


static void ___lambda57_ (Customiser* self) {
	PinDef* _tmp0_;
	_tmp0_ = self->priv->selectedPin;
	if (_tmp0_ != NULL) {
		PinDef* _tmp1_;
		GtkEntry* _tmp2_;
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		gchar* _tmp5_;
		_tmp1_ = self->priv->selectedPin;
		_tmp2_ = self->priv->pinLabelEntry;
		_tmp3_ = gtk_entry_get_text (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (_tmp1_->label);
		_tmp1_->label = _tmp5_;
		customiser_render_def (self);
	}
}


static void ____lambda57__gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	___lambda57_ (self);
}


static void _customiser_update_bounds_gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self) {
	customiser_update_bounds (self);
}


static void __lambda58_ (Customiser* self) {
	customiser_set_colour (self);
}


static void ___lambda58__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda58_ (self);
}


static void _customiser_response_handler_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	customiser_response_handler (self, response_id);
}


static void customiser_populate (Customiser* self) {
	DesignerWindow* _tmp0_;
	GtkDialog* _tmp1_;
	GtkDialog* _tmp2_;
	GtkDialog* _tmp3_;
	GtkWidget* _tmp4_ = NULL;
	GtkBox* _tmp5_;
	GtkBox* content;
	GtkDialog* _tmp6_;
	GtkDialog* _tmp7_;
	GtkHBox* _tmp8_;
	GtkHBox* _tmp9_;
	GtkBox* _tmp10_;
	GtkHBox* _tmp11_;
	GtkEventBox* _tmp12_;
	GtkEventBox* _tmp13_;
	GtkHBox* _tmp14_;
	GtkEventBox* _tmp15_;
	GtkEventBox* _tmp16_;
	GtkEventBox* _tmp17_;
	GtkDrawingArea* _tmp18_;
	GtkDrawingArea* _tmp19_;
	GtkEventBox* _tmp20_;
	GtkDrawingArea* _tmp21_;
	GtkDrawingArea* _tmp22_;
	GtkDrawingArea* _tmp23_;
	GtkVBox* _tmp24_;
	GtkVBox* _tmp25_;
	GtkHBox* _tmp26_;
	GtkVBox* _tmp27_;
	GtkHBox* _tmp28_;
	GtkHBox* _tmp29_;
	GtkVBox* _tmp30_;
	GtkHBox* _tmp31_;
	GtkLabel* _tmp32_;
	GtkLabel* _tmp33_;
	GtkHBox* _tmp34_;
	GtkLabel* _tmp35_;
	GtkEntry* _tmp36_;
	GtkEntry* _tmp37_;
	GtkEntry* _tmp38_;
	CustomComponentDef* _tmp39_;
	const gchar* _tmp40_;
	GtkHBox* _tmp41_;
	GtkEntry* _tmp42_;
	GtkHBox* _tmp43_;
	GtkHBox* _tmp44_;
	GtkVBox* _tmp45_;
	GtkHBox* _tmp46_;
	GtkLabel* _tmp47_;
	GtkLabel* _tmp48_;
	GtkHBox* _tmp49_;
	GtkLabel* _tmp50_;
	GtkEntry* _tmp51_;
	GtkEntry* _tmp52_;
	GtkEntry* _tmp53_;
	CustomComponentDef* _tmp54_;
	const gchar* _tmp55_;
	GtkHBox* _tmp56_;
	GtkEntry* _tmp57_;
	GtkHBox* _tmp58_;
	GtkHBox* _tmp59_;
	GtkVBox* _tmp60_;
	GtkHBox* _tmp61_;
	GtkLabel* _tmp62_;
	GtkLabel* _tmp63_;
	GtkHBox* _tmp64_;
	GtkLabel* _tmp65_;
	GtkEntry* _tmp66_;
	GtkEntry* _tmp67_;
	GtkEntry* _tmp68_;
	CustomComponentDef* _tmp69_;
	const gchar* _tmp70_;
	GtkEntry* _tmp71_;
	GtkHBox* _tmp72_;
	GtkEntry* _tmp73_;
	CustomComponentDef* _tmp74_;
	PinDef** _tmp75_;
	gint _tmp75__length1;
	GtkLabel* _tmp166_;
	GtkLabel* _tmp167_;
	GtkVBox* _tmp168_;
	GtkLabel* _tmp169_;
	GtkTable* _tmp170_;
	GtkTable* _tmp171_;
	GtkVBox* _tmp172_;
	GtkTable* _tmp173_;
	GtkLabel* _tmp174_;
	GtkLabel* _tmp175_;
	GtkTable* _tmp176_;
	GtkLabel* _tmp177_;
	gint _tmp178_;
	GtkSpinButton* _tmp179_;
	GtkSpinButton* _tmp180_;
	GtkSpinButton* _tmp181_;
	CustomComponentDef* _tmp182_;
	gint _tmp183_;
	GtkSpinButton* _tmp184_;
	GtkTable* _tmp185_;
	GtkSpinButton* _tmp186_;
	GtkLabel* _tmp187_;
	GtkLabel* _tmp188_;
	GtkTable* _tmp189_;
	GtkLabel* _tmp190_;
	gint _tmp191_;
	GtkSpinButton* _tmp192_;
	GtkSpinButton* _tmp193_;
	GtkSpinButton* _tmp194_;
	CustomComponentDef* _tmp195_;
	gint _tmp196_;
	GtkSpinButton* _tmp197_;
	GtkTable* _tmp198_;
	GtkSpinButton* _tmp199_;
	GtkLabel* _tmp200_;
	GtkLabel* _tmp201_;
	GtkTable* _tmp202_;
	GtkLabel* _tmp203_;
	gint _tmp204_;
	GtkSpinButton* _tmp205_;
	GtkSpinButton* _tmp206_;
	GtkSpinButton* _tmp207_;
	CustomComponentDef* _tmp208_;
	gint _tmp209_;
	GtkSpinButton* _tmp210_;
	GtkTable* _tmp211_;
	GtkSpinButton* _tmp212_;
	GtkLabel* _tmp213_;
	GtkLabel* _tmp214_;
	GtkTable* _tmp215_;
	GtkLabel* _tmp216_;
	gint _tmp217_;
	GtkSpinButton* _tmp218_;
	GtkSpinButton* _tmp219_;
	GtkSpinButton* _tmp220_;
	CustomComponentDef* _tmp221_;
	gint _tmp222_;
	GtkSpinButton* _tmp223_;
	GtkTable* _tmp224_;
	GtkSpinButton* _tmp225_;
	GtkButton* _tmp226_;
	GtkButton* _tmp227_;
	GtkButton* _tmp228_;
	GtkVBox* _tmp229_;
	GtkButton* _tmp230_;
	GtkDialog* _tmp231_;
	GtkButton* _tmp232_;
	GtkButton* _tmp233_;
	GtkDialog* _tmp234_;
	GtkButton* _tmp235_;
	GtkDialog* _tmp236_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->parent;
	_tmp1_ = (GtkDialog*) gtk_dialog_new_with_buttons ("Customise Component", (GtkWindow*) _tmp0_, GTK_DIALOG_MODAL, NULL);
	_tmp2_ = g_object_ref_sink (_tmp1_);
	_g_object_unref0 (self->priv->dialog);
	self->priv->dialog = _tmp2_;
	_tmp3_ = self->priv->dialog;
	_tmp4_ = gtk_dialog_get_content_area (_tmp3_);
	_tmp5_ = _g_object_ref0 (GTK_IS_BOX (_tmp4_) ? ((GtkBox*) _tmp4_) : NULL);
	content = _tmp5_;
	_tmp6_ = self->priv->dialog;
	gtk_window_set_default_size ((GtkWindow*) _tmp6_, 600, 200);
	_tmp7_ = self->priv->dialog;
	gtk_container_set_border_width ((GtkContainer*) _tmp7_, (guint) 1);
	_tmp8_ = (GtkHBox*) gtk_hbox_new (FALSE, 2);
	_tmp9_ = g_object_ref_sink (_tmp8_);
	_g_object_unref0 (self->priv->layoutHBox);
	self->priv->layoutHBox = _tmp9_;
	_tmp10_ = content;
	_tmp11_ = self->priv->layoutHBox;
	gtk_box_pack_start (_tmp10_, (GtkWidget*) _tmp11_, TRUE, TRUE, (guint) 1);
	_tmp12_ = (GtkEventBox*) gtk_event_box_new ();
	_tmp13_ = g_object_ref_sink (_tmp12_);
	_g_object_unref0 (self->priv->controller);
	self->priv->controller = _tmp13_;
	_tmp14_ = self->priv->layoutHBox;
	_tmp15_ = self->priv->controller;
	gtk_box_pack_start ((GtkBox*) _tmp14_, (GtkWidget*) _tmp15_, TRUE, TRUE, (guint) 1);
	_tmp16_ = self->priv->controller;
	g_signal_connect ((GtkWidget*) _tmp16_, "button-press-event", (GCallback) _customiser_mouse_down_gtk_widget_button_press_event, self);
	_tmp17_ = self->priv->controller;
	g_signal_connect ((GtkWidget*) _tmp17_, "button-release-event", (GCallback) _customiser_mouse_up_gtk_widget_button_release_event, self);
	_tmp18_ = (GtkDrawingArea*) gtk_drawing_area_new ();
	_tmp19_ = g_object_ref_sink (_tmp18_);
	_g_object_unref0 (self->priv->display);
	self->priv->display = _tmp19_;
	_tmp20_ = self->priv->controller;
	_tmp21_ = self->priv->display;
	gtk_container_add ((GtkContainer*) _tmp20_, (GtkWidget*) _tmp21_);
	_tmp22_ = self->priv->display;
	g_signal_connect ((GtkWidget*) _tmp22_, "expose-event", (GCallback) ___lambda53__gtk_widget_expose_event, self);
	_tmp23_ = self->priv->display;
	g_signal_connect ((GtkWidget*) _tmp23_, "configure-event", (GCallback) ___lambda54__gtk_widget_configure_event, self);
	_tmp24_ = (GtkVBox*) gtk_vbox_new (FALSE, 2);
	_tmp25_ = g_object_ref_sink (_tmp24_);
	_g_object_unref0 (self->priv->controlsVBox);
	self->priv->controlsVBox = _tmp25_;
	_tmp26_ = self->priv->layoutHBox;
	_tmp27_ = self->priv->controlsVBox;
	gtk_box_pack_start ((GtkBox*) _tmp26_, (GtkWidget*) _tmp27_, FALSE, TRUE, (guint) 1);
	_tmp28_ = (GtkHBox*) gtk_hbox_new (FALSE, 2);
	_tmp29_ = g_object_ref_sink (_tmp28_);
	_g_object_unref0 (self->priv->nameHBox);
	self->priv->nameHBox = _tmp29_;
	_tmp30_ = self->priv->controlsVBox;
	_tmp31_ = self->priv->nameHBox;
	gtk_box_pack_start ((GtkBox*) _tmp30_, (GtkWidget*) _tmp31_, FALSE, TRUE, (guint) 1);
	_tmp32_ = (GtkLabel*) gtk_label_new ("Name:");
	_tmp33_ = g_object_ref_sink (_tmp32_);
	_g_object_unref0 (self->priv->nameLabel);
	self->priv->nameLabel = _tmp33_;
	_tmp34_ = self->priv->nameHBox;
	_tmp35_ = self->priv->nameLabel;
	gtk_box_pack_start ((GtkBox*) _tmp34_, (GtkWidget*) _tmp35_, FALSE, TRUE, (guint) 1);
	_tmp36_ = (GtkEntry*) gtk_entry_new ();
	_tmp37_ = g_object_ref_sink (_tmp36_);
	_g_object_unref0 (self->priv->nameEntry);
	self->priv->nameEntry = _tmp37_;
	_tmp38_ = self->priv->nameEntry;
	_tmp39_ = self->priv->customComponentDef;
	_tmp40_ = ((ComponentDef*) _tmp39_)->name;
	gtk_entry_set_text (_tmp38_, _tmp40_);
	_tmp41_ = self->priv->nameHBox;
	_tmp42_ = self->priv->nameEntry;
	gtk_box_pack_start ((GtkBox*) _tmp41_, (GtkWidget*) _tmp42_, TRUE, TRUE, (guint) 1);
	_tmp43_ = (GtkHBox*) gtk_hbox_new (FALSE, 2);
	_tmp44_ = g_object_ref_sink (_tmp43_);
	_g_object_unref0 (self->priv->descriptionHBox);
	self->priv->descriptionHBox = _tmp44_;
	_tmp45_ = self->priv->controlsVBox;
	_tmp46_ = self->priv->descriptionHBox;
	gtk_box_pack_start ((GtkBox*) _tmp45_, (GtkWidget*) _tmp46_, FALSE, TRUE, (guint) 1);
	_tmp47_ = (GtkLabel*) gtk_label_new ("Description:");
	_tmp48_ = g_object_ref_sink (_tmp47_);
	_g_object_unref0 (self->priv->descriptionLabel);
	self->priv->descriptionLabel = _tmp48_;
	_tmp49_ = self->priv->descriptionHBox;
	_tmp50_ = self->priv->descriptionLabel;
	gtk_box_pack_start ((GtkBox*) _tmp49_, (GtkWidget*) _tmp50_, FALSE, TRUE, (guint) 1);
	_tmp51_ = (GtkEntry*) gtk_entry_new ();
	_tmp52_ = g_object_ref_sink (_tmp51_);
	_g_object_unref0 (self->priv->descriptionEntry);
	self->priv->descriptionEntry = _tmp52_;
	_tmp53_ = self->priv->descriptionEntry;
	_tmp54_ = self->priv->customComponentDef;
	_tmp55_ = ((ComponentDef*) _tmp54_)->description;
	gtk_entry_set_text (_tmp53_, _tmp55_);
	_tmp56_ = self->priv->descriptionHBox;
	_tmp57_ = self->priv->descriptionEntry;
	gtk_box_pack_start ((GtkBox*) _tmp56_, (GtkWidget*) _tmp57_, TRUE, TRUE, (guint) 1);
	_tmp58_ = (GtkHBox*) gtk_hbox_new (FALSE, 2);
	_tmp59_ = g_object_ref_sink (_tmp58_);
	_g_object_unref0 (self->priv->labelHBox);
	self->priv->labelHBox = _tmp59_;
	_tmp60_ = self->priv->controlsVBox;
	_tmp61_ = self->priv->labelHBox;
	gtk_box_pack_start ((GtkBox*) _tmp60_, (GtkWidget*) _tmp61_, FALSE, TRUE, (guint) 1);
	_tmp62_ = (GtkLabel*) gtk_label_new ("Box Label:");
	_tmp63_ = g_object_ref_sink (_tmp62_);
	_g_object_unref0 (self->priv->labelLabel);
	self->priv->labelLabel = _tmp63_;
	_tmp64_ = self->priv->labelHBox;
	_tmp65_ = self->priv->labelLabel;
	gtk_box_pack_start ((GtkBox*) _tmp64_, (GtkWidget*) _tmp65_, FALSE, TRUE, (guint) 1);
	_tmp66_ = (GtkEntry*) gtk_entry_new ();
	_tmp67_ = g_object_ref_sink (_tmp66_);
	_g_object_unref0 (self->priv->labelEntry);
	self->priv->labelEntry = _tmp67_;
	_tmp68_ = self->priv->labelEntry;
	_tmp69_ = self->priv->customComponentDef;
	_tmp70_ = ((ComponentDef*) _tmp69_)->label;
	gtk_entry_set_text (_tmp68_, _tmp70_);
	_tmp71_ = self->priv->labelEntry;
	g_signal_connect ((GtkEditable*) _tmp71_, "changed", (GCallback) ___lambda55__gtk_editable_changed, self);
	_tmp72_ = self->priv->labelHBox;
	_tmp73_ = self->priv->labelEntry;
	gtk_box_pack_start ((GtkBox*) _tmp72_, (GtkWidget*) _tmp73_, TRUE, TRUE, (guint) 1);
	_tmp74_ = self->priv->customComponentDef;
	_tmp75_ = ((ComponentDef*) _tmp74_)->pinDefs;
	_tmp75__length1 = ((ComponentDef*) _tmp74_)->pinDefs_length1;
	if (_tmp75__length1 > 0) {
		CustomComponentDef* _tmp76_;
		PinDef** _tmp77_;
		gint _tmp77__length1;
		gint _tmp78_;
		PinDef* _tmp79_;
		PinDef* _tmp80_;
		CustomComponentDef* _tmp81_;
		gint _tmp82_;
		Tag* _tmp83_ = NULL;
		GtkHBox* _tmp84_;
		GtkHBox* _tmp85_;
		GtkVBox* _tmp86_;
		GtkHBox* _tmp87_;
		GtkLabel* _tmp88_;
		GtkLabel* _tmp89_;
		GtkHBox* _tmp90_;
		GtkLabel* _tmp91_;
		CustomComponentDef* _tmp92_;
		PinDef** _tmp93_;
		gint _tmp93__length1;
		GtkSpinButton* _tmp94_;
		GtkSpinButton* _tmp95_;
		GtkSpinButton* _tmp96_;
		GtkSpinButton* _tmp97_;
		GtkHBox* _tmp98_;
		GtkSpinButton* _tmp99_;
		Tag* _tmp100_;
		GtkVBox* _tmp109_;
		GtkLabel* _tmp110_;
		GtkCheckButton* _tmp111_;
		GtkCheckButton* _tmp112_;
		GtkCheckButton* _tmp113_;
		PinDef* _tmp114_;
		gboolean _tmp115_;
		GtkCheckButton* _tmp116_;
		GtkVBox* _tmp117_;
		GtkCheckButton* _tmp118_;
		GtkVBox* _tmp119_;
		GtkVBox* _tmp120_;
		GtkVBox* _tmp121_;
		GtkVBox* _tmp122_;
		GtkLabel* _tmp123_;
		GtkLabel* _tmp124_;
		GtkVBox* _tmp125_;
		GtkLabel* _tmp126_;
		GtkRadioButton* _tmp127_;
		GtkRadioButton* _tmp128_;
		GtkRadioButton* _tmp129_;
		GtkVBox* _tmp130_;
		GtkRadioButton* _tmp131_;
		GtkRadioButton* _tmp132_;
		GtkRadioButton* _tmp133_;
		GtkRadioButton* _tmp134_;
		GtkRadioButton* _tmp135_;
		GtkVBox* _tmp136_;
		GtkRadioButton* _tmp137_;
		GtkRadioButton* _tmp138_;
		GtkRadioButton* _tmp139_;
		GtkRadioButton* _tmp140_;
		GtkRadioButton* _tmp141_;
		GtkVBox* _tmp142_;
		GtkRadioButton* _tmp143_;
		GtkRadioButton* _tmp144_;
		GtkRadioButton* _tmp145_;
		GtkRadioButton* _tmp146_;
		GtkRadioButton* _tmp147_;
		GtkVBox* _tmp148_;
		GtkRadioButton* _tmp149_;
		GtkHBox* _tmp150_;
		GtkHBox* _tmp151_;
		GtkVBox* _tmp152_;
		GtkHBox* _tmp153_;
		GtkLabel* _tmp154_;
		GtkLabel* _tmp155_;
		GtkHBox* _tmp156_;
		GtkLabel* _tmp157_;
		GtkEntry* _tmp158_;
		GtkEntry* _tmp159_;
		GtkEntry* _tmp160_;
		PinDef* _tmp161_;
		const gchar* _tmp162_;
		GtkEntry* _tmp163_;
		GtkHBox* _tmp164_;
		GtkEntry* _tmp165_;
		self->priv->selectedPinID = 0;
		_tmp76_ = self->priv->customComponentDef;
		_tmp77_ = ((ComponentDef*) _tmp76_)->pinDefs;
		_tmp77__length1 = ((ComponentDef*) _tmp76_)->pinDefs_length1;
		_tmp78_ = self->priv->selectedPinID;
		_tmp79_ = _tmp77_[_tmp78_];
		_tmp80_ = _pin_def_ref0 (_tmp79_);
		_pin_def_unref0 (self->priv->selectedPin);
		self->priv->selectedPin = _tmp80_;
		_tmp81_ = self->priv->customComponentDef;
		_tmp82_ = self->priv->selectedPinID;
		_tmp83_ = custom_component_def_resolve_tag_id (_tmp81_, _tmp82_);
		_tag_unref0 (self->priv->tag);
		self->priv->tag = _tmp83_;
		_tmp84_ = (GtkHBox*) gtk_hbox_new (FALSE, 2);
		_tmp85_ = g_object_ref_sink (_tmp84_);
		_g_object_unref0 (self->priv->pinHBox);
		self->priv->pinHBox = _tmp85_;
		_tmp86_ = self->priv->controlsVBox;
		_tmp87_ = self->priv->pinHBox;
		gtk_box_pack_start ((GtkBox*) _tmp86_, (GtkWidget*) _tmp87_, FALSE, TRUE, (guint) 1);
		_tmp88_ = (GtkLabel*) gtk_label_new ("Pin Select:");
		_tmp89_ = g_object_ref_sink (_tmp88_);
		_g_object_unref0 (self->priv->pinLabel);
		self->priv->pinLabel = _tmp89_;
		_tmp90_ = self->priv->pinHBox;
		_tmp91_ = self->priv->pinLabel;
		gtk_box_pack_start ((GtkBox*) _tmp90_, (GtkWidget*) _tmp91_, FALSE, TRUE, (guint) 1);
		_tmp92_ = self->priv->customComponentDef;
		_tmp93_ = ((ComponentDef*) _tmp92_)->pinDefs;
		_tmp93__length1 = ((ComponentDef*) _tmp92_)->pinDefs_length1;
		_tmp94_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) (_tmp93__length1 - 1), (gdouble) 1);
		_tmp95_ = g_object_ref_sink (_tmp94_);
		_g_object_unref0 (self->priv->pinSpinButton);
		self->priv->pinSpinButton = _tmp95_;
		_tmp96_ = self->priv->pinSpinButton;
		gtk_spin_button_set_value (_tmp96_, (gdouble) 0);
		_tmp97_ = self->priv->pinSpinButton;
		g_signal_connect ((GtkEditable*) _tmp97_, "changed", (GCallback) _customiser_update_selection_gtk_editable_changed, self);
		_tmp98_ = self->priv->pinHBox;
		_tmp99_ = self->priv->pinSpinButton;
		gtk_box_pack_start ((GtkBox*) _tmp98_, (GtkWidget*) _tmp99_, TRUE, TRUE, (guint) 1);
		_tmp100_ = self->priv->tag;
		if (_tmp100_ != NULL) {
			Tag* _tmp101_;
			const gchar* _tmp102_;
			gchar* _tmp103_;
			gchar* _tmp104_;
			GtkLabel* _tmp105_;
			GtkLabel* _tmp106_;
			_tmp101_ = self->priv->tag;
			_tmp102_ = _tmp101_->text;
			_tmp103_ = g_strconcat ("Maps to: ", _tmp102_, NULL);
			_tmp104_ = _tmp103_;
			_tmp105_ = (GtkLabel*) gtk_label_new (_tmp104_);
			_tmp106_ = g_object_ref_sink (_tmp105_);
			_g_object_unref0 (self->priv->tagNameLabel);
			self->priv->tagNameLabel = _tmp106_;
			_g_free0 (_tmp104_);
		} else {
			GtkLabel* _tmp107_;
			GtkLabel* _tmp108_;
			_tmp107_ = (GtkLabel*) gtk_label_new ("There is no matching tag!");
			_tmp108_ = g_object_ref_sink (_tmp107_);
			_g_object_unref0 (self->priv->tagNameLabel);
			self->priv->tagNameLabel = _tmp108_;
		}
		_tmp109_ = self->priv->controlsVBox;
		_tmp110_ = self->priv->tagNameLabel;
		gtk_box_pack_start ((GtkBox*) _tmp109_, (GtkWidget*) _tmp110_, FALSE, TRUE, (guint) 1);
		_tmp111_ = (GtkCheckButton*) gtk_check_button_new_with_label ("Connection Required");
		_tmp112_ = g_object_ref_sink (_tmp111_);
		_g_object_unref0 (self->priv->requiredCheck);
		self->priv->requiredCheck = _tmp112_;
		_tmp113_ = self->priv->requiredCheck;
		_tmp114_ = self->priv->selectedPin;
		_tmp115_ = _tmp114_->required;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp113_, _tmp115_);
		_tmp116_ = self->priv->requiredCheck;
		g_signal_connect ((GtkToggleButton*) _tmp116_, "toggled", (GCallback) ____lambda56__gtk_toggle_button_toggled, self);
		_tmp117_ = self->priv->controlsVBox;
		_tmp118_ = self->priv->requiredCheck;
		gtk_box_pack_start ((GtkBox*) _tmp117_, (GtkWidget*) _tmp118_, FALSE, TRUE, (guint) 1);
		_tmp119_ = (GtkVBox*) gtk_vbox_new (FALSE, 0);
		_tmp120_ = g_object_ref_sink (_tmp119_);
		_g_object_unref0 (self->priv->labelTypeVBox);
		self->priv->labelTypeVBox = _tmp120_;
		_tmp121_ = self->priv->controlsVBox;
		_tmp122_ = self->priv->labelTypeVBox;
		gtk_box_pack_start ((GtkBox*) _tmp121_, (GtkWidget*) _tmp122_, FALSE, TRUE, (guint) 1);
		_tmp123_ = (GtkLabel*) gtk_label_new ("Pin labels can be text or a symbol:");
		_tmp124_ = g_object_ref_sink (_tmp123_);
		_g_object_unref0 (self->priv->labelTypeLabel);
		self->priv->labelTypeLabel = _tmp124_;
		_tmp125_ = self->priv->labelTypeVBox;
		_tmp126_ = self->priv->labelTypeLabel;
		gtk_box_pack_start ((GtkBox*) _tmp125_, (GtkWidget*) _tmp126_, FALSE, TRUE, (guint) 1);
		_tmp127_ = (GtkRadioButton*) gtk_radio_button_new_with_label (NULL, "No Label");
		_tmp128_ = g_object_ref_sink (_tmp127_);
		_g_object_unref0 (self->priv->labelTypeNoneRadio);
		self->priv->labelTypeNoneRadio = _tmp128_;
		_tmp129_ = self->priv->labelTypeNoneRadio;
		g_signal_connect ((GtkToggleButton*) _tmp129_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp130_ = self->priv->labelTypeVBox;
		_tmp131_ = self->priv->labelTypeNoneRadio;
		gtk_box_pack_start ((GtkBox*) _tmp130_, (GtkWidget*) _tmp131_, FALSE, TRUE, (guint) 1);
		_tmp132_ = self->priv->labelTypeNoneRadio;
		_tmp133_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp132_, "Text");
		_tmp134_ = g_object_ref_sink (_tmp133_);
		_g_object_unref0 (self->priv->labelTypeTextRadio);
		self->priv->labelTypeTextRadio = _tmp134_;
		_tmp135_ = self->priv->labelTypeTextRadio;
		g_signal_connect ((GtkToggleButton*) _tmp135_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp136_ = self->priv->labelTypeVBox;
		_tmp137_ = self->priv->labelTypeTextRadio;
		gtk_box_pack_start ((GtkBox*) _tmp136_, (GtkWidget*) _tmp137_, FALSE, TRUE, (guint) 1);
		_tmp138_ = self->priv->labelTypeNoneRadio;
		_tmp139_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp138_, "Text With Bar");
		_tmp140_ = g_object_ref_sink (_tmp139_);
		_g_object_unref0 (self->priv->labelTypeTextBarRadio);
		self->priv->labelTypeTextBarRadio = _tmp140_;
		_tmp141_ = self->priv->labelTypeTextBarRadio;
		g_signal_connect ((GtkToggleButton*) _tmp141_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp142_ = self->priv->labelTypeVBox;
		_tmp143_ = self->priv->labelTypeTextBarRadio;
		gtk_box_pack_start ((GtkBox*) _tmp142_, (GtkWidget*) _tmp143_, FALSE, TRUE, (guint) 1);
		_tmp144_ = self->priv->labelTypeNoneRadio;
		_tmp145_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp144_, "Clock");
		_tmp146_ = g_object_ref_sink (_tmp145_);
		_g_object_unref0 (self->priv->labelTypeClockRadio);
		self->priv->labelTypeClockRadio = _tmp146_;
		_tmp147_ = self->priv->labelTypeClockRadio;
		g_signal_connect ((GtkToggleButton*) _tmp147_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp148_ = self->priv->labelTypeVBox;
		_tmp149_ = self->priv->labelTypeClockRadio;
		gtk_box_pack_start ((GtkBox*) _tmp148_, (GtkWidget*) _tmp149_, FALSE, TRUE, (guint) 1);
		_tmp150_ = (GtkHBox*) gtk_hbox_new (FALSE, 2);
		_tmp151_ = g_object_ref_sink (_tmp150_);
		_g_object_unref0 (self->priv->pinLabelHBox);
		self->priv->pinLabelHBox = _tmp151_;
		_tmp152_ = self->priv->controlsVBox;
		_tmp153_ = self->priv->pinLabelHBox;
		gtk_box_pack_start ((GtkBox*) _tmp152_, (GtkWidget*) _tmp153_, FALSE, TRUE, (guint) 1);
		_tmp154_ = (GtkLabel*) gtk_label_new ("Pin Label:");
		_tmp155_ = g_object_ref_sink (_tmp154_);
		_g_object_unref0 (self->priv->pinLabelLabel);
		self->priv->pinLabelLabel = _tmp155_;
		_tmp156_ = self->priv->pinLabelHBox;
		_tmp157_ = self->priv->pinLabelLabel;
		gtk_box_pack_start ((GtkBox*) _tmp156_, (GtkWidget*) _tmp157_, FALSE, TRUE, (guint) 1);
		_tmp158_ = (GtkEntry*) gtk_entry_new ();
		_tmp159_ = g_object_ref_sink (_tmp158_);
		_g_object_unref0 (self->priv->pinLabelEntry);
		self->priv->pinLabelEntry = _tmp159_;
		_tmp160_ = self->priv->pinLabelEntry;
		_tmp161_ = self->priv->selectedPin;
		_tmp162_ = _tmp161_->label;
		gtk_entry_set_text (_tmp160_, _tmp162_);
		_tmp163_ = self->priv->pinLabelEntry;
		g_signal_connect ((GtkEditable*) _tmp163_, "changed", (GCallback) ____lambda57__gtk_editable_changed, self);
		_tmp164_ = self->priv->pinLabelHBox;
		_tmp165_ = self->priv->pinLabelEntry;
		gtk_box_pack_start ((GtkBox*) _tmp164_, (GtkWidget*) _tmp165_, TRUE, TRUE, (guint) 1);
	}
	_tmp166_ = (GtkLabel*) gtk_label_new ("Bounds define the visual size:");
	_tmp167_ = g_object_ref_sink (_tmp166_);
	_g_object_unref0 (self->priv->boundsLabel);
	self->priv->boundsLabel = _tmp167_;
	_tmp168_ = self->priv->controlsVBox;
	_tmp169_ = self->priv->boundsLabel;
	gtk_box_pack_start ((GtkBox*) _tmp168_, (GtkWidget*) _tmp169_, FALSE, TRUE, (guint) 1);
	_tmp170_ = (GtkTable*) gtk_table_new ((guint) 2, (guint) 4, FALSE);
	_tmp171_ = g_object_ref_sink (_tmp170_);
	_g_object_unref0 (self->priv->boundsTable);
	self->priv->boundsTable = _tmp171_;
	_tmp172_ = self->priv->controlsVBox;
	_tmp173_ = self->priv->boundsTable;
	gtk_box_pack_start ((GtkBox*) _tmp172_, (GtkWidget*) _tmp173_, FALSE, TRUE, (guint) 1);
	_tmp174_ = (GtkLabel*) gtk_label_new ("Right:");
	_tmp175_ = g_object_ref_sink (_tmp174_);
	_g_object_unref0 (self->priv->rightBoundLabel);
	self->priv->rightBoundLabel = _tmp175_;
	_tmp176_ = self->priv->boundsTable;
	_tmp177_ = self->priv->rightBoundLabel;
	gtk_table_attach_defaults (_tmp176_, (GtkWidget*) _tmp177_, (guint) 0, (guint) 1, (guint) 0, (guint) 1);
	_tmp178_ = G_MAXINT;
	_tmp179_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) _tmp178_, (gdouble) 5);
	_tmp180_ = g_object_ref_sink (_tmp179_);
	_g_object_unref0 (self->priv->rightBoundSpinButton);
	self->priv->rightBoundSpinButton = _tmp180_;
	_tmp181_ = self->priv->rightBoundSpinButton;
	_tmp182_ = self->priv->customComponentDef;
	_tmp183_ = ((ComponentDef*) _tmp182_)->rightBound;
	gtk_spin_button_set_value (_tmp181_, (gdouble) _tmp183_);
	_tmp184_ = self->priv->rightBoundSpinButton;
	g_signal_connect (_tmp184_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp185_ = self->priv->boundsTable;
	_tmp186_ = self->priv->rightBoundSpinButton;
	gtk_table_attach_defaults (_tmp185_, (GtkWidget*) _tmp186_, (guint) 1, (guint) 2, (guint) 0, (guint) 1);
	_tmp187_ = (GtkLabel*) gtk_label_new ("Down:");
	_tmp188_ = g_object_ref_sink (_tmp187_);
	_g_object_unref0 (self->priv->downBoundLabel);
	self->priv->downBoundLabel = _tmp188_;
	_tmp189_ = self->priv->boundsTable;
	_tmp190_ = self->priv->downBoundLabel;
	gtk_table_attach_defaults (_tmp189_, (GtkWidget*) _tmp190_, (guint) 0, (guint) 1, (guint) 1, (guint) 2);
	_tmp191_ = G_MAXINT;
	_tmp192_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) _tmp191_, (gdouble) 5);
	_tmp193_ = g_object_ref_sink (_tmp192_);
	_g_object_unref0 (self->priv->downBoundSpinButton);
	self->priv->downBoundSpinButton = _tmp193_;
	_tmp194_ = self->priv->downBoundSpinButton;
	_tmp195_ = self->priv->customComponentDef;
	_tmp196_ = ((ComponentDef*) _tmp195_)->downBound;
	gtk_spin_button_set_value (_tmp194_, (gdouble) _tmp196_);
	_tmp197_ = self->priv->downBoundSpinButton;
	g_signal_connect (_tmp197_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp198_ = self->priv->boundsTable;
	_tmp199_ = self->priv->downBoundSpinButton;
	gtk_table_attach_defaults (_tmp198_, (GtkWidget*) _tmp199_, (guint) 1, (guint) 2, (guint) 1, (guint) 2);
	_tmp200_ = (GtkLabel*) gtk_label_new ("Left:");
	_tmp201_ = g_object_ref_sink (_tmp200_);
	_g_object_unref0 (self->priv->leftBoundLabel);
	self->priv->leftBoundLabel = _tmp201_;
	_tmp202_ = self->priv->boundsTable;
	_tmp203_ = self->priv->leftBoundLabel;
	gtk_table_attach_defaults (_tmp202_, (GtkWidget*) _tmp203_, (guint) 0, (guint) 1, (guint) 2, (guint) 3);
	_tmp204_ = G_MININT;
	_tmp205_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) _tmp204_, (gdouble) 0, (gdouble) 5);
	_tmp206_ = g_object_ref_sink (_tmp205_);
	_g_object_unref0 (self->priv->leftBoundSpinButton);
	self->priv->leftBoundSpinButton = _tmp206_;
	_tmp207_ = self->priv->leftBoundSpinButton;
	_tmp208_ = self->priv->customComponentDef;
	_tmp209_ = ((ComponentDef*) _tmp208_)->leftBound;
	gtk_spin_button_set_value (_tmp207_, (gdouble) _tmp209_);
	_tmp210_ = self->priv->leftBoundSpinButton;
	g_signal_connect (_tmp210_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp211_ = self->priv->boundsTable;
	_tmp212_ = self->priv->leftBoundSpinButton;
	gtk_table_attach_defaults (_tmp211_, (GtkWidget*) _tmp212_, (guint) 1, (guint) 2, (guint) 2, (guint) 3);
	_tmp213_ = (GtkLabel*) gtk_label_new ("Up:");
	_tmp214_ = g_object_ref_sink (_tmp213_);
	_g_object_unref0 (self->priv->upBoundLabel);
	self->priv->upBoundLabel = _tmp214_;
	_tmp215_ = self->priv->boundsTable;
	_tmp216_ = self->priv->upBoundLabel;
	gtk_table_attach_defaults (_tmp215_, (GtkWidget*) _tmp216_, (guint) 0, (guint) 1, (guint) 3, (guint) 4);
	_tmp217_ = G_MININT;
	_tmp218_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) _tmp217_, (gdouble) 0, (gdouble) 5);
	_tmp219_ = g_object_ref_sink (_tmp218_);
	_g_object_unref0 (self->priv->upBoundSpinButton);
	self->priv->upBoundSpinButton = _tmp219_;
	_tmp220_ = self->priv->upBoundSpinButton;
	_tmp221_ = self->priv->customComponentDef;
	_tmp222_ = ((ComponentDef*) _tmp221_)->upBound;
	gtk_spin_button_set_value (_tmp220_, (gdouble) _tmp222_);
	_tmp223_ = self->priv->upBoundSpinButton;
	g_signal_connect (_tmp223_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp224_ = self->priv->boundsTable;
	_tmp225_ = self->priv->upBoundSpinButton;
	gtk_table_attach_defaults (_tmp224_, (GtkWidget*) _tmp225_, (guint) 1, (guint) 2, (guint) 3, (guint) 4);
	_tmp226_ = (GtkButton*) gtk_button_new_with_label ("Background Colour");
	_tmp227_ = g_object_ref_sink (_tmp226_);
	_g_object_unref0 (self->priv->colourButton);
	self->priv->colourButton = _tmp227_;
	_tmp228_ = self->priv->colourButton;
	g_signal_connect (_tmp228_, "clicked", (GCallback) ___lambda58__gtk_button_clicked, self);
	_tmp229_ = self->priv->controlsVBox;
	_tmp230_ = self->priv->colourButton;
	gtk_box_pack_start ((GtkBox*) _tmp229_, (GtkWidget*) _tmp230_, FALSE, TRUE, (guint) 1);
	_tmp231_ = self->priv->dialog;
	g_signal_connect (_tmp231_, "response", (GCallback) _customiser_response_handler_gtk_dialog_response, self);
	_tmp232_ = (GtkButton*) gtk_button_new_with_label ("Close");
	_tmp233_ = g_object_ref_sink (_tmp232_);
	_g_object_unref0 (self->priv->closeButton);
	self->priv->closeButton = _tmp233_;
	_tmp234_ = self->priv->dialog;
	_tmp235_ = self->priv->closeButton;
	gtk_dialog_add_action_widget (_tmp234_, (GtkWidget*) _tmp235_, (gint) GTK_RESPONSE_CLOSE);
	_tmp236_ = self->priv->dialog;
	gtk_widget_show_all ((GtkWidget*) _tmp236_);
	_g_object_unref0 (content);
}


/**
 * Signal handler for the Gtk.EventBox. Handles a mouse button down
 * event on the display area.
 */
static gboolean customiser_mouse_down (Customiser* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GdkEventButton _tmp0_;
	gdouble _tmp1_;
	GdkEventButton _tmp2_;
	gdouble _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.x;
	self->priv->xMouseStart = (gint) _tmp1_;
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.y;
	self->priv->yMouseStart = (gint) _tmp3_;
	result = FALSE;
	return result;
}


/**
 * Signal handler for the Gtk.EventBox. Handles a mouse button up
 * event on the display area. This is when an action is taken.
 * 
 * Only changes the pins' positions.
 */
static gboolean customiser_mouse_up (Customiser* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GtkAllocation areaAllocation = {0};
	GtkEventBox* _tmp0_;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_;
	gint _tmp3_;
	gint width;
	GtkAllocation _tmp4_;
	gint _tmp5_;
	gint height;
	DesignerWindow* _tmp6_;
	gint _tmp7_;
	gint halfGridSize;
	gint _tmp8_;
	gint xCentre;
	gint _tmp9_;
	gint yCentre;
	gint _tmp10_;
	gint _tmp11_;
	gint xStart;
	gint _tmp12_;
	gint _tmp13_;
	gint yStart;
	GdkEventButton _tmp14_;
	gdouble _tmp15_;
	gint _tmp16_;
	gint xEnd;
	GdkEventButton _tmp17_;
	gdouble _tmp18_;
	gint _tmp19_;
	gint yEnd;
	gint _tmp20_;
	gint xBoardStart;
	gint _tmp21_;
	gint yBoardStart;
	gint _tmp22_;
	gint xBoardEnd;
	gint _tmp23_;
	gint yBoardEnd;
	gint _tmp24_ = 0;
	gint _tmp25_;
	gint _tmp28_;
	gint _tmp29_;
	gint _tmp30_ = 0;
	gint _tmp31_;
	gint _tmp34_;
	gint _tmp35_;
	gint _tmp36_;
	DesignerWindow* _tmp37_;
	gint _tmp38_;
	DesignerWindow* _tmp39_;
	gint _tmp40_;
	gint _tmp41_;
	DesignerWindow* _tmp42_;
	gint _tmp43_;
	DesignerWindow* _tmp44_;
	gint _tmp45_;
	gint _tmp46_ = 0;
	gint _tmp47_;
	gint _tmp50_;
	gint _tmp51_;
	gint _tmp52_ = 0;
	gint _tmp53_;
	gint _tmp56_;
	gint _tmp57_;
	gint _tmp58_;
	DesignerWindow* _tmp59_;
	gint _tmp60_;
	DesignerWindow* _tmp61_;
	gint _tmp62_;
	gint _tmp63_;
	DesignerWindow* _tmp64_;
	gint _tmp65_;
	DesignerWindow* _tmp66_;
	gint _tmp67_;
	FILE* _tmp68_;
	gint _tmp69_;
	gint _tmp70_;
	gint _tmp71_;
	gint _tmp72_;
	CustomComponentDef* _tmp73_;
	gint _tmp74_;
	gint rightBound;
	CustomComponentDef* _tmp75_;
	gint _tmp76_;
	gint downBound;
	CustomComponentDef* _tmp77_;
	gint _tmp78_;
	gint leftBound;
	CustomComponentDef* _tmp79_;
	gint _tmp80_;
	gint upBound;
	gboolean _tmp81_ = FALSE;
	gint _tmp82_;
	gint _tmp83_;
	gboolean _tmp86_;
	gboolean _tmp101_ = FALSE;
	gint _tmp102_;
	gint _tmp103_;
	gboolean _tmp106_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->controller;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	areaAllocation = _tmp1_;
	_tmp2_ = areaAllocation;
	_tmp3_ = _tmp2_.width;
	width = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.height;
	height = _tmp5_;
	_tmp6_ = self->priv->parent;
	_tmp7_ = _tmp6_->gridSize;
	halfGridSize = _tmp7_ / 2;
	_tmp8_ = width;
	xCentre = _tmp8_ / 2;
	_tmp9_ = height;
	yCentre = _tmp9_ / 2;
	_tmp10_ = self->priv->xMouseStart;
	_tmp11_ = xCentre;
	xStart = _tmp10_ - _tmp11_;
	_tmp12_ = self->priv->yMouseStart;
	_tmp13_ = yCentre;
	yStart = _tmp12_ - _tmp13_;
	_tmp14_ = *event;
	_tmp15_ = _tmp14_.x;
	_tmp16_ = xCentre;
	xEnd = ((gint) _tmp15_) - _tmp16_;
	_tmp17_ = *event;
	_tmp18_ = _tmp17_.y;
	_tmp19_ = yCentre;
	yEnd = ((gint) _tmp18_) - _tmp19_;
	_tmp20_ = xStart;
	xBoardStart = _tmp20_;
	_tmp21_ = yStart;
	yBoardStart = _tmp21_;
	_tmp22_ = xEnd;
	xBoardEnd = _tmp22_;
	_tmp23_ = yEnd;
	yBoardEnd = _tmp23_;
	_tmp25_ = xBoardStart;
	if (_tmp25_ > 0) {
		gint _tmp26_;
		_tmp26_ = halfGridSize;
		_tmp24_ = _tmp26_;
	} else {
		gint _tmp27_;
		_tmp27_ = halfGridSize;
		_tmp24_ = -_tmp27_;
	}
	_tmp28_ = xBoardStart;
	_tmp29_ = _tmp24_;
	xBoardStart = _tmp28_ + _tmp29_;
	_tmp31_ = yBoardStart;
	if (_tmp31_ > 0) {
		gint _tmp32_;
		_tmp32_ = halfGridSize;
		_tmp30_ = _tmp32_;
	} else {
		gint _tmp33_;
		_tmp33_ = halfGridSize;
		_tmp30_ = -_tmp33_;
	}
	_tmp34_ = yBoardStart;
	_tmp35_ = _tmp30_;
	yBoardStart = _tmp34_ + _tmp35_;
	_tmp36_ = xBoardStart;
	_tmp37_ = self->priv->parent;
	_tmp38_ = _tmp37_->gridSize;
	_tmp39_ = self->priv->parent;
	_tmp40_ = _tmp39_->gridSize;
	xBoardStart = (_tmp36_ / _tmp38_) * _tmp40_;
	_tmp41_ = yBoardStart;
	_tmp42_ = self->priv->parent;
	_tmp43_ = _tmp42_->gridSize;
	_tmp44_ = self->priv->parent;
	_tmp45_ = _tmp44_->gridSize;
	yBoardStart = (_tmp41_ / _tmp43_) * _tmp45_;
	_tmp47_ = xBoardEnd;
	if (_tmp47_ > 0) {
		gint _tmp48_;
		_tmp48_ = halfGridSize;
		_tmp46_ = _tmp48_;
	} else {
		gint _tmp49_;
		_tmp49_ = halfGridSize;
		_tmp46_ = -_tmp49_;
	}
	_tmp50_ = xBoardEnd;
	_tmp51_ = _tmp46_;
	xBoardEnd = _tmp50_ + _tmp51_;
	_tmp53_ = yBoardEnd;
	if (_tmp53_ > 0) {
		gint _tmp54_;
		_tmp54_ = halfGridSize;
		_tmp52_ = _tmp54_;
	} else {
		gint _tmp55_;
		_tmp55_ = halfGridSize;
		_tmp52_ = -_tmp55_;
	}
	_tmp56_ = yBoardEnd;
	_tmp57_ = _tmp52_;
	yBoardEnd = _tmp56_ + _tmp57_;
	_tmp58_ = xBoardEnd;
	_tmp59_ = self->priv->parent;
	_tmp60_ = _tmp59_->gridSize;
	_tmp61_ = self->priv->parent;
	_tmp62_ = _tmp61_->gridSize;
	xBoardEnd = (_tmp58_ / _tmp60_) * _tmp62_;
	_tmp63_ = yBoardEnd;
	_tmp64_ = self->priv->parent;
	_tmp65_ = _tmp64_->gridSize;
	_tmp66_ = self->priv->parent;
	_tmp67_ = _tmp66_->gridSize;
	yBoardEnd = (_tmp63_ / _tmp65_) * _tmp67_;
	_tmp68_ = stdout;
	_tmp69_ = xBoardStart;
	_tmp70_ = yBoardStart;
	_tmp71_ = xBoardEnd;
	_tmp72_ = yBoardEnd;
	fprintf (_tmp68_, "Customiser Interact @ %i, %i - %i, %i\n", _tmp69_, _tmp70_, _tmp71_, _tmp72_);
	_tmp73_ = self->priv->customComponentDef;
	_tmp74_ = ((ComponentDef*) _tmp73_)->rightBound;
	rightBound = _tmp74_;
	_tmp75_ = self->priv->customComponentDef;
	_tmp76_ = ((ComponentDef*) _tmp75_)->downBound;
	downBound = _tmp76_;
	_tmp77_ = self->priv->customComponentDef;
	_tmp78_ = ((ComponentDef*) _tmp77_)->leftBound;
	leftBound = _tmp78_;
	_tmp79_ = self->priv->customComponentDef;
	_tmp80_ = ((ComponentDef*) _tmp79_)->upBound;
	upBound = _tmp80_;
	_tmp82_ = upBound;
	_tmp83_ = yBoardEnd;
	if (_tmp82_ <= _tmp83_) {
		gint _tmp84_;
		gint _tmp85_;
		_tmp84_ = yBoardEnd;
		_tmp85_ = downBound;
		_tmp81_ = _tmp84_ <= _tmp85_;
	} else {
		_tmp81_ = FALSE;
	}
	_tmp86_ = _tmp81_;
	if (_tmp86_) {
		gint _tmp87_;
		gint _tmp88_;
		gint _tmp94_;
		gint _tmp95_;
		_tmp87_ = xBoardEnd;
		_tmp88_ = leftBound;
		if (_tmp87_ < _tmp88_) {
			PinDef* _tmp89_;
			gint _tmp90_;
			gint _tmp91_;
			gint _tmp92_;
			gint _tmp93_;
			_tmp89_ = self->priv->selectedPin;
			_tmp90_ = leftBound;
			_tmp91_ = yBoardEnd;
			_tmp92_ = leftBound;
			_tmp93_ = xBoardEnd;
			pin_def_set_position (_tmp89_, _tmp90_, _tmp91_, _tmp92_ - _tmp93_, DIRECTION_LEFT);
		}
		_tmp94_ = xBoardEnd;
		_tmp95_ = rightBound;
		if (_tmp94_ > _tmp95_) {
			PinDef* _tmp96_;
			gint _tmp97_;
			gint _tmp98_;
			gint _tmp99_;
			gint _tmp100_;
			_tmp96_ = self->priv->selectedPin;
			_tmp97_ = rightBound;
			_tmp98_ = yBoardEnd;
			_tmp99_ = xBoardEnd;
			_tmp100_ = rightBound;
			pin_def_set_position (_tmp96_, _tmp97_, _tmp98_, _tmp99_ - _tmp100_, DIRECTION_RIGHT);
		}
	}
	_tmp102_ = leftBound;
	_tmp103_ = xBoardEnd;
	if (_tmp102_ <= _tmp103_) {
		gint _tmp104_;
		gint _tmp105_;
		_tmp104_ = xBoardEnd;
		_tmp105_ = rightBound;
		_tmp101_ = _tmp104_ <= _tmp105_;
	} else {
		_tmp101_ = FALSE;
	}
	_tmp106_ = _tmp101_;
	if (_tmp106_) {
		gint _tmp107_;
		gint _tmp108_;
		gint _tmp114_;
		gint _tmp115_;
		_tmp107_ = yBoardEnd;
		_tmp108_ = upBound;
		if (_tmp107_ < _tmp108_) {
			PinDef* _tmp109_;
			gint _tmp110_;
			gint _tmp111_;
			gint _tmp112_;
			gint _tmp113_;
			_tmp109_ = self->priv->selectedPin;
			_tmp110_ = xBoardEnd;
			_tmp111_ = upBound;
			_tmp112_ = upBound;
			_tmp113_ = yBoardEnd;
			pin_def_set_position (_tmp109_, _tmp110_, _tmp111_, _tmp112_ - _tmp113_, DIRECTION_UP);
		}
		_tmp114_ = yBoardEnd;
		_tmp115_ = downBound;
		if (_tmp114_ > _tmp115_) {
			PinDef* _tmp116_;
			gint _tmp117_;
			gint _tmp118_;
			gint _tmp119_;
			gint _tmp120_;
			_tmp116_ = self->priv->selectedPin;
			_tmp117_ = xBoardEnd;
			_tmp118_ = downBound;
			_tmp119_ = yBoardEnd;
			_tmp120_ = downBound;
			pin_def_set_position (_tmp116_, _tmp117_, _tmp118_, _tmp119_ - _tmp120_, DIRECTION_DOWN);
		}
	}
	customiser_update_values (self);
	customiser_render_def (self);
	result = FALSE;
	return result;
}


/**
 * Called when the Customiser should become modal.
 */
void customiser_run (Customiser* self) {
	GtkDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->dialog;
	gtk_dialog_run (_tmp0_);
}


/**
 * Handles the response of the customiser dialog. (On close.)
 */
void customiser_response_handler (Customiser* self, gint response_id) {
	GtkDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	customiser_update_values (self);
	_tmp0_ = self->priv->dialog;
	gtk_object_destroy ((GtkObject*) _tmp0_);
}


void customiser_set_colour (Customiser* self) {
	GtkColorSelectionDialog* _tmp0_;
	GtkColorSelectionDialog* _tmp1_;
	GtkColorSelectionDialog* colorDialog;
	GtkColorSelectionDialog* _tmp2_;
	GtkWidget* _tmp3_ = NULL;
	GtkColorSelection* _tmp4_;
	GtkColorSelection* colorSelection;
	GdkColor color = {0};
	GtkColorSelection* _tmp5_;
	CustomComponentDef* _tmp6_;
	gint _tmp7_;
	CustomComponentDef* _tmp8_;
	gint _tmp9_;
	CustomComponentDef* _tmp10_;
	gint _tmp11_;
	CustomComponentDef* _tmp12_;
	gint _tmp13_;
	GtkColorSelection* _tmp22_;
	GdkColor _tmp23_;
	GtkColorSelection* _tmp24_;
	GdkColor _tmp25_;
	GtkColorSelectionDialog* _tmp26_;
	gint _tmp27_ = 0;
	GtkColorSelectionDialog* _tmp54_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkColorSelectionDialog*) gtk_color_selection_dialog_new ("Component Background");
	_tmp1_ = g_object_ref_sink (_tmp0_);
	colorDialog = _tmp1_;
	_tmp2_ = colorDialog;
	_tmp3_ = gtk_color_selection_dialog_get_color_selection (_tmp2_);
	_tmp4_ = _g_object_ref0 (GTK_COLOR_SELECTION (_tmp3_));
	colorSelection = _tmp4_;
	memset (&color, 0, sizeof (GdkColor));
	_tmp5_ = colorSelection;
	gtk_color_selection_set_has_opacity_control (_tmp5_, TRUE);
	_tmp6_ = self->priv->customComponentDef;
	_tmp7_ = ((ComponentDef*) _tmp6_)->backgroundRed;
	color.red = (guint16) (_tmp7_ * 257);
	_tmp8_ = self->priv->customComponentDef;
	_tmp9_ = ((ComponentDef*) _tmp8_)->backgroundGreen;
	color.green = (guint16) (_tmp9_ * 257);
	_tmp10_ = self->priv->customComponentDef;
	_tmp11_ = ((ComponentDef*) _tmp10_)->backgroundBlue;
	color.blue = (guint16) (_tmp11_ * 257);
	_tmp12_ = self->priv->customComponentDef;
	_tmp13_ = ((ComponentDef*) _tmp12_)->backgroundAlpha;
	if (_tmp13_ == 0) {
		GtkColorSelection* _tmp14_;
		GtkColorSelection* _tmp15_;
		_tmp14_ = colorSelection;
		gtk_color_selection_set_previous_alpha (_tmp14_, (guint16) 65535);
		_tmp15_ = colorSelection;
		gtk_color_selection_set_current_alpha (_tmp15_, (guint16) 65535);
	} else {
		GtkColorSelection* _tmp16_;
		CustomComponentDef* _tmp17_;
		gint _tmp18_;
		GtkColorSelection* _tmp19_;
		CustomComponentDef* _tmp20_;
		gint _tmp21_;
		_tmp16_ = colorSelection;
		_tmp17_ = self->priv->customComponentDef;
		_tmp18_ = ((ComponentDef*) _tmp17_)->backgroundAlpha;
		gtk_color_selection_set_previous_alpha (_tmp16_, (guint16) (_tmp18_ * 257));
		_tmp19_ = colorSelection;
		_tmp20_ = self->priv->customComponentDef;
		_tmp21_ = ((ComponentDef*) _tmp20_)->backgroundAlpha;
		gtk_color_selection_set_current_alpha (_tmp19_, (guint16) (_tmp21_ * 257));
	}
	_tmp22_ = colorSelection;
	_tmp23_ = color;
	gtk_color_selection_set_previous_color (_tmp22_, &_tmp23_);
	_tmp24_ = colorSelection;
	_tmp25_ = color;
	gtk_color_selection_set_current_color (_tmp24_, &_tmp25_);
	_tmp26_ = colorDialog;
	_tmp27_ = gtk_dialog_run ((GtkDialog*) _tmp26_);
	if (_tmp27_ == ((gint) GTK_RESPONSE_OK)) {
		GtkColorSelection* _tmp28_;
		GdkColor _tmp29_ = {0};
		CustomComponentDef* _tmp30_;
		GtkColorSelection* _tmp31_;
		guint16 _tmp32_ = 0U;
		CustomComponentDef* _tmp33_;
		GdkColor _tmp34_;
		guint16 _tmp35_;
		CustomComponentDef* _tmp36_;
		GdkColor _tmp37_;
		guint16 _tmp38_;
		CustomComponentDef* _tmp39_;
		GdkColor _tmp40_;
		guint16 _tmp41_;
		CustomComponentDef* _tmp42_;
		CustomComponentDef* _tmp43_;
		gint _tmp44_;
		CustomComponentDef* _tmp45_;
		CustomComponentDef* _tmp46_;
		gint _tmp47_;
		CustomComponentDef* _tmp48_;
		CustomComponentDef* _tmp49_;
		gint _tmp50_;
		CustomComponentDef* _tmp51_;
		CustomComponentDef* _tmp52_;
		gint _tmp53_;
		_tmp28_ = colorSelection;
		gtk_color_selection_get_current_color (_tmp28_, &_tmp29_);
		color = _tmp29_;
		_tmp30_ = self->priv->customComponentDef;
		_tmp31_ = colorSelection;
		_tmp32_ = gtk_color_selection_get_current_alpha (_tmp31_);
		((ComponentDef*) _tmp30_)->backgroundAlpha = ((gint) _tmp32_) / 257;
		_tmp33_ = self->priv->customComponentDef;
		_tmp34_ = color;
		_tmp35_ = _tmp34_.red;
		((ComponentDef*) _tmp33_)->backgroundRed = ((gint) _tmp35_) / 257;
		_tmp36_ = self->priv->customComponentDef;
		_tmp37_ = color;
		_tmp38_ = _tmp37_.green;
		((ComponentDef*) _tmp36_)->backgroundGreen = ((gint) _tmp38_) / 257;
		_tmp39_ = self->priv->customComponentDef;
		_tmp40_ = color;
		_tmp41_ = _tmp40_.blue;
		((ComponentDef*) _tmp39_)->backgroundBlue = ((gint) _tmp41_) / 257;
		_tmp42_ = self->priv->customComponentDef;
		_tmp43_ = self->priv->customComponentDef;
		_tmp44_ = ((ComponentDef*) _tmp43_)->backgroundAlpha;
		((ComponentDef*) _tmp42_)->backgroundAlphaF = ((gdouble) _tmp44_) / 255.0;
		_tmp45_ = self->priv->customComponentDef;
		_tmp46_ = self->priv->customComponentDef;
		_tmp47_ = ((ComponentDef*) _tmp46_)->backgroundRed;
		((ComponentDef*) _tmp45_)->backgroundRedF = ((gdouble) _tmp47_) / 255.0;
		_tmp48_ = self->priv->customComponentDef;
		_tmp49_ = self->priv->customComponentDef;
		_tmp50_ = ((ComponentDef*) _tmp49_)->backgroundGreen;
		((ComponentDef*) _tmp48_)->backgroundGreenF = ((gdouble) _tmp50_) / 255.0;
		_tmp51_ = self->priv->customComponentDef;
		_tmp52_ = self->priv->customComponentDef;
		_tmp53_ = ((ComponentDef*) _tmp52_)->backgroundBlue;
		((ComponentDef*) _tmp51_)->backgroundBlueF = ((gdouble) _tmp53_) / 255.0;
	}
	_tmp54_ = colorDialog;
	gtk_object_destroy ((GtkObject*) _tmp54_);
	customiser_render_def (self);
	_g_object_unref0 (colorSelection);
	_g_object_unref0 (colorDialog);
}


/**
 * Set generic information. Called when closing the dialog.
 */
void customiser_update_values (Customiser* self) {
	GtkEntry* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	CustomComponentDef* _tmp3_;
	const gchar* _tmp4_;
	CustomComponentDef* _tmp30_;
	GtkEntry* _tmp31_;
	const gchar* _tmp32_;
	const gchar* _tmp33_;
	gchar* _tmp34_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->nameEntry;
	_tmp1_ = gtk_entry_get_text (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->customComponentDef;
	_tmp4_ = ((ComponentDef*) _tmp3_)->name;
	if (g_strcmp0 (_tmp2_, _tmp4_) != 0) {
		Project* _tmp5_;
		GtkEntry* _tmp6_;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		ComponentDef* _tmp9_ = NULL;
		ComponentDef* _tmp10_;
		gboolean _tmp11_;
		_tmp5_ = self->priv->project;
		_tmp6_ = self->priv->nameEntry;
		_tmp7_ = gtk_entry_get_text (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = project_resolve_def_name (_tmp5_, _tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = _tmp10_ == NULL;
		_component_def_unref0 (_tmp10_);
		if (_tmp11_) {
			CustomComponentDef* _tmp12_;
			GtkEntry* _tmp13_;
			const gchar* _tmp14_;
			const gchar* _tmp15_;
			gchar* _tmp16_;
			_tmp12_ = self->priv->customComponentDef;
			_tmp13_ = self->priv->nameEntry;
			_tmp14_ = gtk_entry_get_text (_tmp13_);
			_tmp15_ = _tmp14_;
			_tmp16_ = g_strdup (_tmp15_);
			_g_free0 (((ComponentDef*) _tmp12_)->name);
			((ComponentDef*) _tmp12_)->name = _tmp16_;
		} else {
			GtkEntry* _tmp17_;
			const gchar* _tmp18_;
			const gchar* _tmp19_;
			gchar* _tmp20_;
			gchar* _tmp21_;
			gchar* _tmp22_;
			gchar* _tmp23_;
			CustomComponentDef* _tmp24_;
			const gchar* _tmp25_;
			gchar* _tmp26_;
			gchar* _tmp27_;
			gchar* _tmp28_;
			gchar* _tmp29_;
			_tmp17_ = self->priv->nameEntry;
			_tmp18_ = gtk_entry_get_text (_tmp17_);
			_tmp19_ = _tmp18_;
			_tmp20_ = g_strconcat ("A component with the name \"", _tmp19_, NULL);
			_tmp21_ = _tmp20_;
			_tmp22_ = g_strconcat (_tmp21_, "\" already exists. It may be a built-in component or a custom componen" \
"t. This component's name will remain \"", NULL);
			_tmp23_ = _tmp22_;
			_tmp24_ = self->priv->customComponentDef;
			_tmp25_ = ((ComponentDef*) _tmp24_)->name;
			_tmp26_ = g_strconcat (_tmp23_, _tmp25_, NULL);
			_tmp27_ = _tmp26_;
			_tmp28_ = g_strconcat (_tmp27_, "\".", NULL);
			_tmp29_ = _tmp28_;
			basic_dialog_error (NULL, _tmp29_);
			_g_free0 (_tmp29_);
			_g_free0 (_tmp27_);
			_g_free0 (_tmp23_);
			_g_free0 (_tmp21_);
		}
	}
	_tmp30_ = self->priv->customComponentDef;
	_tmp31_ = self->priv->descriptionEntry;
	_tmp32_ = gtk_entry_get_text (_tmp31_);
	_tmp33_ = _tmp32_;
	_tmp34_ = g_strdup (_tmp33_);
	_g_free0 (((ComponentDef*) _tmp30_)->description);
	((ComponentDef*) _tmp30_)->description = _tmp34_;
}


/**
 * Set, from radio buttons, what type of label a pin should use.
 */
void customiser_update_label_type (Customiser* self) {
	PinDef* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->selectedPin;
	if (_tmp0_ != NULL) {
		GtkRadioButton* _tmp1_;
		gboolean _tmp2_;
		gboolean _tmp3_;
		_tmp1_ = self->priv->labelTypeNoneRadio;
		_tmp2_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp1_);
		_tmp3_ = _tmp2_;
		if (_tmp3_) {
			PinDef* _tmp4_;
			_tmp4_ = self->priv->selectedPin;
			_tmp4_->labelType = PIN_DEF_LABEL_TYPE_NONE;
		} else {
			GtkRadioButton* _tmp5_;
			gboolean _tmp6_;
			gboolean _tmp7_;
			_tmp5_ = self->priv->labelTypeTextRadio;
			_tmp6_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp5_);
			_tmp7_ = _tmp6_;
			if (_tmp7_) {
				PinDef* _tmp8_;
				_tmp8_ = self->priv->selectedPin;
				_tmp8_->labelType = PIN_DEF_LABEL_TYPE_TEXT;
			} else {
				GtkRadioButton* _tmp9_;
				gboolean _tmp10_;
				gboolean _tmp11_;
				_tmp9_ = self->priv->labelTypeTextBarRadio;
				_tmp10_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp9_);
				_tmp11_ = _tmp10_;
				if (_tmp11_) {
					PinDef* _tmp12_;
					_tmp12_ = self->priv->selectedPin;
					_tmp12_->labelType = PIN_DEF_LABEL_TYPE_TEXTBAR;
				} else {
					GtkRadioButton* _tmp13_;
					gboolean _tmp14_;
					gboolean _tmp15_;
					_tmp13_ = self->priv->labelTypeClockRadio;
					_tmp14_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp13_);
					_tmp15_ = _tmp14_;
					if (_tmp15_) {
						PinDef* _tmp16_;
						_tmp16_ = self->priv->selectedPin;
						_tmp16_->labelType = PIN_DEF_LABEL_TYPE_CLOCK;
					}
				}
			}
		}
		customiser_render_def (self);
	}
}


/**
 * Set, from spin buttons, what the bounds of the component are.
 */
void customiser_update_bounds (Customiser* self) {
	CustomComponentDef* _tmp0_;
	GtkSpinButton* _tmp1_;
	gint _tmp2_ = 0;
	CustomComponentDef* _tmp3_;
	GtkSpinButton* _tmp4_;
	gint _tmp5_ = 0;
	CustomComponentDef* _tmp6_;
	GtkSpinButton* _tmp7_;
	gint _tmp8_ = 0;
	CustomComponentDef* _tmp9_;
	GtkSpinButton* _tmp10_;
	gint _tmp11_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->customComponentDef;
	_tmp1_ = self->priv->rightBoundSpinButton;
	_tmp2_ = gtk_spin_button_get_value_as_int (_tmp1_);
	((ComponentDef*) _tmp0_)->rightBound = _tmp2_;
	_tmp3_ = self->priv->customComponentDef;
	_tmp4_ = self->priv->downBoundSpinButton;
	_tmp5_ = gtk_spin_button_get_value_as_int (_tmp4_);
	((ComponentDef*) _tmp3_)->downBound = _tmp5_;
	_tmp6_ = self->priv->customComponentDef;
	_tmp7_ = self->priv->leftBoundSpinButton;
	_tmp8_ = gtk_spin_button_get_value_as_int (_tmp7_);
	((ComponentDef*) _tmp6_)->leftBound = _tmp8_;
	_tmp9_ = self->priv->customComponentDef;
	_tmp10_ = self->priv->upBoundSpinButton;
	_tmp11_ = gtk_spin_button_get_value_as_int (_tmp10_);
	((ComponentDef*) _tmp9_)->upBound = _tmp11_;
	customiser_render_def (self);
}


/**
 * Update widgets to show the information of the selected pin.
 */
void customiser_update_selection (Customiser* self) {
	CustomComponentDef* _tmp0_;
	PinDef** _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->customComponentDef;
	_tmp1_ = ((ComponentDef*) _tmp0_)->pinDefs;
	_tmp1__length1 = ((ComponentDef*) _tmp0_)->pinDefs_length1;
	if (_tmp1__length1 > 0) {
		GtkSpinButton* _tmp2_;
		gint _tmp3_ = 0;
		CustomComponentDef* _tmp4_;
		PinDef** _tmp5_;
		gint _tmp5__length1;
		gint _tmp6_;
		PinDef* _tmp7_;
		PinDef* _tmp8_;
		CustomComponentDef* _tmp9_;
		gint _tmp10_;
		Tag* _tmp11_ = NULL;
		PinDef* _tmp12_;
		PinDefLabelType _tmp13_;
		Tag* _tmp18_;
		GtkEntry* _tmp31_;
		PinDef* _tmp32_;
		const gchar* _tmp33_;
		GtkCheckButton* _tmp34_;
		PinDef* _tmp35_;
		gboolean _tmp36_;
		_tmp2_ = self->priv->pinSpinButton;
		_tmp3_ = gtk_spin_button_get_value_as_int (_tmp2_);
		self->priv->selectedPinID = _tmp3_;
		_tmp4_ = self->priv->customComponentDef;
		_tmp5_ = ((ComponentDef*) _tmp4_)->pinDefs;
		_tmp5__length1 = ((ComponentDef*) _tmp4_)->pinDefs_length1;
		_tmp6_ = self->priv->selectedPinID;
		_tmp7_ = _tmp5_[_tmp6_];
		_tmp8_ = _pin_def_ref0 (_tmp7_);
		_pin_def_unref0 (self->priv->selectedPin);
		self->priv->selectedPin = _tmp8_;
		_tmp9_ = self->priv->customComponentDef;
		_tmp10_ = self->priv->selectedPinID;
		_tmp11_ = custom_component_def_resolve_tag_id (_tmp9_, _tmp10_);
		_tag_unref0 (self->priv->tag);
		self->priv->tag = _tmp11_;
		_tmp12_ = self->priv->selectedPin;
		_tmp13_ = _tmp12_->labelType;
		switch (_tmp13_) {
			case PIN_DEF_LABEL_TYPE_NONE:
			{
				GtkRadioButton* _tmp14_;
				_tmp14_ = self->priv->labelTypeNoneRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp14_, TRUE);
				break;
			}
			case PIN_DEF_LABEL_TYPE_TEXT:
			{
				GtkRadioButton* _tmp15_;
				_tmp15_ = self->priv->labelTypeTextRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp15_, TRUE);
				break;
			}
			case PIN_DEF_LABEL_TYPE_TEXTBAR:
			{
				GtkRadioButton* _tmp16_;
				_tmp16_ = self->priv->labelTypeTextBarRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp16_, TRUE);
				break;
			}
			case PIN_DEF_LABEL_TYPE_CLOCK:
			{
				GtkRadioButton* _tmp17_;
				_tmp17_ = self->priv->labelTypeClockRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp17_, TRUE);
				break;
			}
			default:
			break;
		}
		_tmp18_ = self->priv->tag;
		if (_tmp18_ != NULL) {
			GtkLabel* _tmp19_;
			Tag* _tmp20_;
			const gchar* _tmp21_;
			gchar* _tmp22_;
			gchar* _tmp23_;
			PinDef* _tmp24_;
			const gchar* _tmp25_;
			_tmp19_ = self->priv->tagNameLabel;
			_tmp20_ = self->priv->tag;
			_tmp21_ = _tmp20_->text;
			_tmp22_ = g_strconcat ("Maps to: ", _tmp21_, NULL);
			_tmp23_ = _tmp22_;
			gtk_label_set_label (_tmp19_, _tmp23_);
			_g_free0 (_tmp23_);
			_tmp24_ = self->priv->selectedPin;
			_tmp25_ = _tmp24_->label;
			if (g_strcmp0 (_tmp25_, "") == 0) {
				PinDef* _tmp26_;
				Tag* _tmp27_;
				const gchar* _tmp28_;
				gchar* _tmp29_;
				_tmp26_ = self->priv->selectedPin;
				_tmp27_ = self->priv->tag;
				_tmp28_ = _tmp27_->text;
				_tmp29_ = g_strdup (_tmp28_);
				_g_free0 (_tmp26_->label);
				_tmp26_->label = _tmp29_;
			}
		} else {
			GtkLabel* _tmp30_;
			_tmp30_ = self->priv->tagNameLabel;
			gtk_label_set_label (_tmp30_, "There is no matching tag!");
		}
		_tmp31_ = self->priv->pinLabelEntry;
		_tmp32_ = self->priv->selectedPin;
		_tmp33_ = _tmp32_->label;
		gtk_entry_set_text (_tmp31_, _tmp33_);
		_tmp34_ = self->priv->requiredCheck;
		_tmp35_ = self->priv->selectedPin;
		_tmp36_ = _tmp35_->required;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp34_, _tmp36_);
	} else {
		_pin_def_unref0 (self->priv->selectedPin);
		self->priv->selectedPin = NULL;
	}
	customiser_render_def (self);
}


/**
 * Render the current box design.
 */
gboolean customiser_render_def (Customiser* self) {
	gboolean result = FALSE;
	gint width = 0;
	gint height = 0;
	GtkAllocation areaAllocation = {0};
	GtkDrawingArea* _tmp0_;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_;
	gint _tmp3_;
	GtkAllocation _tmp4_;
	gint _tmp5_;
	GtkDrawingArea* _tmp6_;
	GdkWindow* _tmp7_;
	cairo_t* _tmp8_ = NULL;
	cairo_t* displayContext;
	cairo_t* _tmp9_;
	cairo_surface_t* _tmp10_ = NULL;
	gint _tmp11_;
	gint _tmp12_;
	cairo_surface_t* _tmp13_;
	cairo_surface_t* offScreenSurface;
	cairo_surface_t* _tmp14_;
	cairo_t* _tmp15_;
	cairo_t* context;
	cairo_t* _tmp16_;
	cairo_surface_t* _tmp17_;
	cairo_t* _tmp18_;
	gboolean _tmp19_ = FALSE;
	DesignerWindow* _tmp20_;
	gboolean _tmp23_;
	cairo_t* _tmp95_;
	gint _tmp96_;
	gint _tmp97_;
	cairo_t* _tmp98_;
	CustomComponentDef* _tmp99_;
	cairo_t* _tmp100_;
	cairo_t* _tmp118_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->display;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	areaAllocation = _tmp1_;
	_tmp2_ = areaAllocation;
	_tmp3_ = _tmp2_.width;
	width = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.height;
	height = _tmp5_;
	_tmp6_ = self->priv->display;
	_tmp7_ = ((GtkWidget*) _tmp6_)->window;
	_tmp8_ = gdk_cairo_create ((GdkDrawable*) _tmp7_);
	displayContext = _tmp8_;
	_tmp9_ = displayContext;
	_tmp10_ = cairo_get_target (_tmp9_);
	_tmp11_ = width;
	_tmp12_ = height;
	_tmp13_ = cairo_surface_create_similar (_tmp10_, CAIRO_CONTENT_COLOR, _tmp11_, _tmp12_);
	offScreenSurface = _tmp13_;
	_tmp14_ = offScreenSurface;
	_tmp15_ = cairo_create (_tmp14_);
	context = _tmp15_;
	_tmp16_ = displayContext;
	_tmp17_ = offScreenSurface;
	cairo_set_source_surface (_tmp16_, _tmp17_, (gdouble) 0, (gdouble) 0);
	_tmp18_ = context;
	cairo_set_line_width (_tmp18_, (gdouble) 1);
	_tmp20_ = self->priv->parent;
	if (_tmp20_ != NULL) {
		DesignerWindow* _tmp21_;
		gboolean _tmp22_;
		_tmp21_ = self->priv->parent;
		_tmp22_ = _tmp21_->showGrid;
		_tmp19_ = _tmp22_;
	} else {
		_tmp19_ = FALSE;
	}
	_tmp23_ = _tmp19_;
	if (_tmp23_) {
		cairo_surface_t* _tmp24_;
		cairo_t* _tmp90_;
		cairo_surface_t* _tmp91_;
		cairo_t* _tmp92_;
		_tmp24_ = self->priv->gridCache;
		if (_tmp24_ == NULL) {
			cairo_t* _tmp25_;
			cairo_surface_t* _tmp26_ = NULL;
			cairo_t* _tmp27_;
			cairo_surface_t* _tmp28_ = NULL;
			cairo_content_t _tmp29_ = 0;
			gint _tmp30_;
			gint _tmp31_;
			cairo_surface_t* _tmp32_;
			cairo_surface_t* _tmp33_;
			cairo_t* _tmp34_;
			cairo_t* gridContext;
			cairo_t* _tmp35_;
			cairo_t* _tmp36_;
			DesignerWindow* _tmp37_;
			gint _tmp38_;
			gfloat spacing;
			gint _tmp43_;
			gfloat _tmp44_;
			gfloat y;
			gint _tmp45_;
			gfloat _tmp46_;
			gfloat x;
			cairo_t* _tmp47_;
			cairo_t* _tmp48_;
			gfloat _tmp49_;
			gdouble* _tmp50_ = NULL;
			gdouble* _tmp51_;
			gint _tmp51__length1;
			gfloat _tmp65_;
			gint _tmp66_;
			gfloat _tmp67_;
			gint _tmp68_;
			gfloat _tmp69_;
			cairo_t* _tmp70_;
			cairo_t* _tmp71_;
			gfloat _tmp72_;
			gdouble* _tmp73_ = NULL;
			gdouble* _tmp74_;
			gint _tmp74__length1;
			cairo_t* _tmp88_;
			cairo_t* _tmp89_;
			_tmp25_ = context;
			_tmp26_ = cairo_get_target (_tmp25_);
			_tmp27_ = context;
			_tmp28_ = cairo_get_target (_tmp27_);
			_tmp29_ = cairo_surface_get_content (_tmp28_);
			_tmp30_ = width;
			_tmp31_ = height;
			_tmp32_ = cairo_surface_create_similar (_tmp26_, _tmp29_, _tmp30_, _tmp31_);
			_cairo_surface_destroy0 (self->priv->gridCache);
			self->priv->gridCache = _tmp32_;
			_tmp33_ = self->priv->gridCache;
			_tmp34_ = cairo_create (_tmp33_);
			gridContext = _tmp34_;
			_tmp35_ = gridContext;
			cairo_set_source_rgb (_tmp35_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
			_tmp36_ = gridContext;
			cairo_paint (_tmp36_);
			_tmp37_ = self->priv->parent;
			_tmp38_ = _tmp37_->gridSize;
			spacing = (gfloat) _tmp38_;
			while (TRUE) {
				gfloat _tmp39_;
				gfloat _tmp40_;
				DesignerWindow* _tmp41_;
				gint _tmp42_;
				_tmp39_ = spacing;
				if (!(_tmp39_ < ((gfloat) 2))) {
					break;
				}
				_tmp40_ = spacing;
				_tmp41_ = self->priv->parent;
				_tmp42_ = _tmp41_->gridSize;
				spacing = _tmp40_ * _tmp42_;
			}
			_tmp43_ = height;
			_tmp44_ = spacing;
			y = fmodf (_tmp43_ / 2, _tmp44_);
			_tmp45_ = width;
			_tmp46_ = spacing;
			x = fmodf (_tmp45_ / 2, _tmp46_);
			_tmp47_ = gridContext;
			cairo_set_source_rgba (_tmp47_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.5);
			_tmp48_ = gridContext;
			_tmp49_ = spacing;
			_tmp50_ = g_new0 (gdouble, 2);
			_tmp50_[0] = 1.0;
			_tmp50_[1] = _tmp49_ - 1.0;
			_tmp51_ = _tmp50_;
			_tmp51__length1 = 2;
			cairo_set_dash (_tmp48_, _tmp51_, 2, (gdouble) 0);
			_tmp51_ = (g_free (_tmp51_), NULL);
			{
				gboolean _tmp52_;
				_tmp52_ = TRUE;
				while (TRUE) {
					gboolean _tmp53_;
					gfloat _tmp56_;
					gint _tmp57_;
					cairo_t* _tmp58_;
					gfloat _tmp59_;
					gfloat _tmp60_;
					cairo_t* _tmp61_;
					gint _tmp62_;
					gfloat _tmp63_;
					cairo_t* _tmp64_;
					_tmp53_ = _tmp52_;
					if (!_tmp53_) {
						gfloat _tmp54_;
						gfloat _tmp55_;
						_tmp54_ = y;
						_tmp55_ = spacing;
						y = _tmp54_ + _tmp55_;
					}
					_tmp52_ = FALSE;
					_tmp56_ = y;
					_tmp57_ = height;
					if (!(_tmp56_ < ((gfloat) _tmp57_))) {
						break;
					}
					_tmp58_ = gridContext;
					_tmp59_ = x;
					_tmp60_ = y;
					cairo_move_to (_tmp58_, (gdouble) _tmp59_, (gdouble) _tmp60_);
					_tmp61_ = gridContext;
					_tmp62_ = width;
					_tmp63_ = y;
					cairo_line_to (_tmp61_, (gdouble) _tmp62_, (gdouble) _tmp63_);
					_tmp64_ = gridContext;
					cairo_stroke (_tmp64_);
				}
			}
			_tmp65_ = spacing;
			spacing = _tmp65_ * 4;
			_tmp66_ = height;
			_tmp67_ = spacing;
			y = fmodf (_tmp66_ / 2, _tmp67_);
			_tmp68_ = width;
			_tmp69_ = spacing;
			x = fmodf (_tmp68_ / 2, _tmp69_);
			_tmp70_ = gridContext;
			cairo_set_source_rgba (_tmp70_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 1.0);
			_tmp71_ = gridContext;
			_tmp72_ = spacing;
			_tmp73_ = g_new0 (gdouble, 2);
			_tmp73_[0] = 1.0;
			_tmp73_[1] = _tmp72_ - 1.0;
			_tmp74_ = _tmp73_;
			_tmp74__length1 = 2;
			cairo_set_dash (_tmp71_, _tmp74_, 2, (gdouble) 0);
			_tmp74_ = (g_free (_tmp74_), NULL);
			{
				gboolean _tmp75_;
				_tmp75_ = TRUE;
				while (TRUE) {
					gboolean _tmp76_;
					gfloat _tmp79_;
					gint _tmp80_;
					cairo_t* _tmp81_;
					gfloat _tmp82_;
					gfloat _tmp83_;
					cairo_t* _tmp84_;
					gint _tmp85_;
					gfloat _tmp86_;
					cairo_t* _tmp87_;
					_tmp76_ = _tmp75_;
					if (!_tmp76_) {
						gfloat _tmp77_;
						gfloat _tmp78_;
						_tmp77_ = y;
						_tmp78_ = spacing;
						y = _tmp77_ + _tmp78_;
					}
					_tmp75_ = FALSE;
					_tmp79_ = y;
					_tmp80_ = height;
					if (!(_tmp79_ < ((gfloat) _tmp80_))) {
						break;
					}
					_tmp81_ = gridContext;
					_tmp82_ = x;
					_tmp83_ = y;
					cairo_move_to (_tmp81_, (gdouble) _tmp82_, (gdouble) _tmp83_);
					_tmp84_ = gridContext;
					_tmp85_ = width;
					_tmp86_ = y;
					cairo_line_to (_tmp84_, (gdouble) _tmp85_, (gdouble) _tmp86_);
					_tmp87_ = gridContext;
					cairo_stroke (_tmp87_);
				}
			}
			_tmp88_ = gridContext;
			cairo_set_dash (_tmp88_, NULL, 0, (gdouble) 0);
			_tmp89_ = gridContext;
			cairo_set_source_rgba (_tmp89_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 1);
			_cairo_destroy0 (gridContext);
		}
		_tmp90_ = context;
		_tmp91_ = self->priv->gridCache;
		cairo_set_source_surface (_tmp90_, _tmp91_, (gdouble) 0, (gdouble) 0);
		_tmp92_ = context;
		cairo_paint (_tmp92_);
	} else {
		cairo_t* _tmp93_;
		cairo_t* _tmp94_;
		_tmp93_ = context;
		cairo_set_source_rgb (_tmp93_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
		_tmp94_ = context;
		cairo_paint (_tmp94_);
	}
	_tmp95_ = context;
	_tmp96_ = width;
	_tmp97_ = height;
	cairo_translate (_tmp95_, (gdouble) (_tmp96_ / 2), (gdouble) (_tmp97_ / 2));
	_tmp98_ = context;
	cairo_set_source_rgb (_tmp98_, (gdouble) 0, (gdouble) 0, (gdouble) 0);
	_tmp99_ = self->priv->customComponentDef;
	_tmp100_ = context;
	component_def_render ((ComponentDef*) _tmp99_, _tmp100_, DIRECTION_RIGHT, FALSE, NULL, TRUE);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp101_;
			_tmp101_ = TRUE;
			while (TRUE) {
				gboolean _tmp102_;
				gint _tmp104_;
				CustomComponentDef* _tmp105_;
				PinDef** _tmp106_;
				gint _tmp106__length1;
				CustomComponentDef* _tmp107_;
				PinDef** _tmp108_;
				gint _tmp108__length1;
				gint _tmp109_;
				PinDef* _tmp110_;
				PinDef* _tmp111_;
				PinDef* pinDef;
				gint _tmp112_;
				gint _tmp113_;
				PinDef* _tmp116_;
				cairo_t* _tmp117_;
				_tmp102_ = _tmp101_;
				if (!_tmp102_) {
					gint _tmp103_;
					_tmp103_ = i;
					i = _tmp103_ + 1;
				}
				_tmp101_ = FALSE;
				_tmp104_ = i;
				_tmp105_ = self->priv->customComponentDef;
				_tmp106_ = ((ComponentDef*) _tmp105_)->pinDefs;
				_tmp106__length1 = ((ComponentDef*) _tmp105_)->pinDefs_length1;
				if (!(_tmp104_ < _tmp106__length1)) {
					break;
				}
				_tmp107_ = self->priv->customComponentDef;
				_tmp108_ = ((ComponentDef*) _tmp107_)->pinDefs;
				_tmp108__length1 = ((ComponentDef*) _tmp107_)->pinDefs_length1;
				_tmp109_ = i;
				_tmp110_ = _tmp108_[_tmp109_];
				_tmp111_ = _pin_def_ref0 (_tmp110_);
				pinDef = _tmp111_;
				_tmp112_ = self->priv->selectedPinID;
				_tmp113_ = i;
				if (_tmp112_ == _tmp113_) {
					cairo_t* _tmp114_;
					_tmp114_ = context;
					cairo_set_source_rgb (_tmp114_, (gdouble) 0, (gdouble) 0, (gdouble) 1);
				} else {
					cairo_t* _tmp115_;
					_tmp115_ = context;
					cairo_set_source_rgb (_tmp115_, (gdouble) 0, (gdouble) 0, (gdouble) 0);
				}
				_tmp116_ = pinDef;
				_tmp117_ = context;
				pin_def_render (_tmp116_, _tmp117_, FALSE);
				_pin_def_unref0 (pinDef);
			}
		}
	}
	_tmp118_ = displayContext;
	cairo_paint (_tmp118_);
	result = FALSE;
	_cairo_destroy0 (context);
	_cairo_surface_destroy0 (offScreenSurface);
	_cairo_destroy0 (displayContext);
	return result;
}


static void value_customiser_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_customiser_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		customiser_unref (value->data[0].v_pointer);
	}
}


static void value_customiser_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = customiser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_customiser_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_customiser_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Customiser* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = customiser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_customiser_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Customiser** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = customiser_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_customiser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecCustomiser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_CUSTOMISER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_customiser (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CUSTOMISER), NULL);
	return value->data[0].v_pointer;
}


void value_set_customiser (GValue* value, gpointer v_object) {
	Customiser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CUSTOMISER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CUSTOMISER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		customiser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		customiser_unref (old);
	}
}


void value_take_customiser (GValue* value, gpointer v_object) {
	Customiser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CUSTOMISER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CUSTOMISER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		customiser_unref (old);
	}
}


static void customiser_class_init (CustomiserClass * klass) {
	customiser_parent_class = g_type_class_peek_parent (klass);
	CUSTOMISER_CLASS (klass)->finalize = customiser_finalize;
	g_type_class_add_private (klass, sizeof (CustomiserPrivate));
}


static void customiser_instance_init (Customiser * self) {
	self->priv = CUSTOMISER_GET_PRIVATE (self);
	self->priv->selectedPinID = 0;
	self->ref_count = 1;
}


static void customiser_finalize (Customiser* obj) {
	Customiser * self;
	self = CUSTOMISER (obj);
	_g_object_unref0 (self->priv->dialog);
	_g_object_unref0 (self->priv->layoutHBox);
	_g_object_unref0 (self->priv->controller);
	_g_object_unref0 (self->priv->display);
	_g_object_unref0 (self->priv->controlsVBox);
	_g_object_unref0 (self->priv->nameHBox);
	_g_object_unref0 (self->priv->nameEntry);
	_g_object_unref0 (self->priv->nameLabel);
	_g_object_unref0 (self->priv->descriptionHBox);
	_g_object_unref0 (self->priv->descriptionEntry);
	_g_object_unref0 (self->priv->descriptionLabel);
	_g_object_unref0 (self->priv->labelHBox);
	_g_object_unref0 (self->priv->labelEntry);
	_g_object_unref0 (self->priv->labelLabel);
	_g_object_unref0 (self->priv->pinHBox);
	_g_object_unref0 (self->priv->pinSpinButton);
	_g_object_unref0 (self->priv->pinLabel);
	_g_object_unref0 (self->priv->tagNameLabel);
	_g_object_unref0 (self->priv->requiredCheck);
	_g_object_unref0 (self->priv->labelTypeVBox);
	_g_object_unref0 (self->priv->labelTypeLabel);
	_g_object_unref0 (self->priv->labelTypeNoneRadio);
	_g_object_unref0 (self->priv->labelTypeTextRadio);
	_g_object_unref0 (self->priv->labelTypeTextBarRadio);
	_g_object_unref0 (self->priv->labelTypeClockRadio);
	_g_object_unref0 (self->priv->pinLabelHBox);
	_g_object_unref0 (self->priv->pinLabelEntry);
	_g_object_unref0 (self->priv->pinLabelLabel);
	_g_object_unref0 (self->priv->boundsLabel);
	_g_object_unref0 (self->priv->boundsTable);
	_g_object_unref0 (self->priv->rightBoundLabel);
	_g_object_unref0 (self->priv->rightBoundSpinButton);
	_g_object_unref0 (self->priv->downBoundLabel);
	_g_object_unref0 (self->priv->downBoundSpinButton);
	_g_object_unref0 (self->priv->leftBoundLabel);
	_g_object_unref0 (self->priv->leftBoundSpinButton);
	_g_object_unref0 (self->priv->upBoundLabel);
	_g_object_unref0 (self->priv->upBoundSpinButton);
	_g_object_unref0 (self->priv->colourButton);
	_g_object_unref0 (self->priv->closeButton);
	_cairo_surface_destroy0 (self->priv->gridCache);
	_component_def_unref0 (self->priv->customComponentDef);
	_g_object_unref0 (self->priv->parent);
	_project_unref0 (self->priv->project);
	_pin_def_unref0 (self->priv->selectedPin);
	_tag_unref0 (self->priv->tag);
}


/**
 * User interface element used to customise a component.
 * 
 * Allows a user to design how a custom component can be used in another
 * component.
 * Used to edit names and descriptions, create a box design, and
 * configure pins.
 */
GType customiser_get_type (void) {
	static volatile gsize customiser_type_id__volatile = 0;
	if (g_once_init_enter (&customiser_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_customiser_init, value_customiser_free_value, value_customiser_copy_value, value_customiser_peek_pointer, "p", value_customiser_collect_value, "p", value_customiser_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (CustomiserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) customiser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Customiser), 0, (GInstanceInitFunc) customiser_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType customiser_type_id;
		customiser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Customiser", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&customiser_type_id__volatile, customiser_type_id);
	}
	return customiser_type_id__volatile;
}


gpointer customiser_ref (gpointer instance) {
	Customiser* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void customiser_unref (gpointer instance) {
	Customiser* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		CUSTOMISER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



